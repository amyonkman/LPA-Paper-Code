---
title: "Edited MIREC Loader"
author: "Original by Josh Alampi, Edited by Amanda Yonkman"
date: "Original Jan 02 2020, Edited July 20, 2020"
output: html_document
---

```{r setup, include=FALSE}
 knitr::opts_chunk$set(echo = TRUE)
```

#Split into 3 parts:
##Part 1: Demographic information/ outcome variables (like WPPSI-III score, birth weight) 
##Part 2: Chemical information
##Part 3: Putting parts 1-2 together 

#################################################
#####Part 1
#################################################

```{r step 1}
####step 1: basic prep
#clear the workspace
rm(list=ls(all=TRUE))

#load packages
library(dplyr)
library(truncnorm)
library(readr)
library(readxl)
library(stringr)

#set the working directory
setwd("/home/ayonkman/Desktop/Raw Data/")
#help: http://rfunction.com/archives/1001

#Load data
baseq <- read_csv("BASELINEQUEST.csv [DATA]") #loads BASELINEQUEST.csv
ndev <- read_csv("NDEV.csv [DATA]") #loads NDEV.csv
mom.data <- read_excel("~/Desktop/Raw Data/MIREC_DVs_INT59_RQ205.xlsx", sheet = "MOTHER_DV") #loads Mother_DV sheet from MIREC_DVs_INT59_RQ205.xlsx
baby.data <- read_excel("~/Desktop/Raw Data/MIREC_DVs_INT59_RQ205.xlsx", sheet = "BABY_DV") #loads Baby_DV sheet from MIREC_DVs_INT59_RQ205.xlsx

labres <- read.csv("Chemical_Data.csv", header=T, sep = ',', stringsAsFactors=FALSE) #file not needed until part 1, but for simplicity it will be loaded now.
#See "original files data dictionary" for how to interpret these uncleaned files 
```

####Step 2: Clean/ prepare the datasets

```{r baby data}
##Prepare Baby's Data - works (AY)

#From the "B_OUTCOME_DV" variable, which has 7 levels, make a more intuitive "live.birth2" variable, which ==1 for live-born children. 
baby.data$live.birth2 <-rep(0,dim(baby.data)[1])
baby.data$live.birth2[baby.data$B_OUTCOME_DV == 0] <- 1 #live births are coded as '1'
baby.data$live.birth2[baby.data$B_OUTCOME_DV == 1 | baby.data$B_OUTCOME_DV == 2 | baby.data$B_OUTCOME_DV == 3 | baby.data$B_OUTCOME_DV == 4 | baby.data$B_OUTCOME_DV == 5 | baby.data$B_OUTCOME_DV == 6] <- 0 #anything else is coded as '0

#remove unnecessary columns 
baby.data <- baby.data %>%
select("SUBJECT_ID", "live.birth2", "BABY_SEX", "GEST_AGE_DV", "BABY_WT", "BABY_LT", "LBW", "SGA", "LGA") #changed to caps to match my data - AY
#rename columns
colnames(baby.data) <- c("subject.id", "live.birth2", "sex2", "gest.age", "birth.wt", "birth.length", "lbw2", "sga2", "lga2") 

#For the sex variable: 
##0: Male; 1: Female; 2:Other (sex="other" only occured when there was no healthy birth.)
###We can thus make all sex=='other' babies as NA, so they can be removed later on. 
baby.data$sex2[baby.data$sex2 == 2] <- NA

# June 15 - adding preterm birth (1 = GA<37 weeks) - AY

baby.data <- mutate(baby.data, preterm2 = ifelse((gest.age<37), 1, 0))

#reorder variables
baby.data <- baby.data[c("subject.id", "birth.length", "birth.wt", "gest.age", "preterm2", "lbw2", "lga2", "live.birth2", "sex2", "sga2")]

baby.data[1:11,] #the baby.data dataframe contains only the desired columns. 

```

```{r srs data}
##Prepare neurodevelopmental data

# Age is in months
# wppsi.1 = receptive vocabulary test
# wppsi.2 = block design test
# wppsi.3 = information test
# wppsi.4 = object assembly test
# wppsi.5 = picture naming test
# All of these are scaled; you can find raw data in the full dataset
# viq, piq, and fsiq are composite; you can find percentile data in the full dataset

#Filtering out/renaming the columns I want:
ndev <- select(ndev, SUBJECT_ID, AgeTestingMonths, WPPSI1_2, WPPSI2_2, WPPSI3_2, WPPSI4_2, WPPSI5_2, WPPSI6_1, WPPSI7_1, WPPSI8_1, WPPSI9_1)
colnames(ndev) <- c("subject.id", "age", "wppsi.1","wppsi.2", "wppsi.3","wppsi.4", "wppsi.5", "viq", "piq", "fsiq", "general.language")
ndev

```

```{r questionaire data}
#Prepare Baseline questionnaire data

#make 6 race variables from question 14. Subjects may be classified as more than one race. 
##race.white:checked off box 1 in the questionnaire
##race.asian:checked off any of the following boxes in the questionnaire: 2,3,5,6,8,9,10,11
##race.black:checked off box 4 in the questionnaire
##race.latin (Latin American): checked off box 7 in the questionnaire
##race.aboriginal :checked off box 12 in the questionnaire (Includes North American Indian, MÃ©tis, or Inuit [Eskimo])
##race.other:checked off box 13 in the questionnaire
##NA (Refusal/don't know): checked off boxes 14 or 15 in the questionnaire) ###nobody checked boxes 14 or 15 in the study, so this is not an issue. 

attach(baseq)

baseq$race.white2 <- rep(0, dim(baseq)[1])
baseq$race.white2[B14_1==1] <- 1

baseq$race.asian2 <- rep(0, dim(baseq)[1])
baseq$race.asian2[B14_2==1 | B14_3==1 | B14_5==1 | B14_6==1 | B14_8==1 | B14_9==1 | B14_10==1 | B14_11==1] <- 1

baseq$race.black2 <- rep(0, dim(baseq)[1])
baseq$race.black2[B14_4==1] <- 1

baseq$race.latin2 <- rep(0, dim(baseq)[1])
baseq$race.latin2[B14_7==1] <- 1

baseq$race.aboriginal2 <- rep(0, dim(baseq)[1])
baseq$race.aboriginal2[B14_12==1] <- 1

baseq$race.other2 <- rep(0, dim(baseq)[1])
baseq$race.other2[B14_13==1] <- 1

detach(baseq)

#Remove unnecessary columns
baseq <- baseq %>%
select("CENTRE", "SUBJECT_ID", "VISIT_DATE", "B10", "B12", "B15", "B16", "B17", "B19", "race.white2", "race.asian2", "race.black2", "race.latin2", "race.aboriginal2", "race.other2")

#Rename remaining columns
colnames(baseq) <- c("site11", "subject.id", "visit.date", "year.born", "edu8", "married7", "living.status5", "income12", "mom.birthplace5", "race.white2", "race.asian2", "race.black2", "race.latin2", "race.aboriginal2", "race.other2") 

##Find the mother's age at enrollment:
baseq$visit.date <- as.numeric(substr(baseq$visit.date,1,4)) # Find the year of the visit date from first 4 characters of the second column of 'baseq'. 
baseq[,dim(baseq)[2]+1] <- baseq$visit.date - baseq$year.born; colnames(baseq)[dim(baseq)[2]]<- "mom.age" # A new column for mother's age is made by subtracting the year of the 1st visitfrom the mother's year of birth. 

#Create a categorical variable for age with 3 levels:
baseq$mom.age3 <-rep(0,dim(baseq)[1])
baseq$mom.age3[baseq$mom.age >= 18 & baseq$mom.age <= 29] <- 1
baseq$mom.age3[baseq$mom.age >= 30 & baseq$mom.age <= 34] <- 2
baseq$mom.age3[baseq$mom.age >= 35] <- 3
baseq$mom.age3[baseq$mom.age3 == 0] <- NA #Respondents who do not meet one of the 3 conditions stated above (ie mothers under 18) are marked as NA, and can bebe removed later

#Remove the now unnecessary "visit.date" and "year.born" columns
baseq <- baseq %>%
select(-c("visit.date", "year.born"))

#Make simpler versions of the demographic variables (the old, more complicated versions will still be retained to give end users a choice)

baseq$city10 <- rep(0, dim(baseq)[1])
baseq$city10[baseq$site11==1] <-1
baseq$city10[baseq$site11==2] <-2
baseq$city10[baseq$site11==3] <-3
baseq$city10[baseq$site11==4] <-4
baseq$city10[baseq$site11==5] <-5
baseq$city10[baseq$site11==6] <-6
baseq$city10[baseq$site11==7] <-7
baseq$city10[baseq$site11==8] <-8
baseq$city10[baseq$site11==9 |baseq$site11==10] <-9
baseq$city10[baseq$site11==11] <- 10

##new education variable has 4 levels
baseq$edu4 <- rep(0, dim(baseq)[1])
baseq$edu4[baseq$edu8==0 | baseq$edu8==1 | baseq$edu8==2] <-1
baseq$edu4[baseq$edu8==3 | baseq$edu8==4 | baseq$edu8==5 ] <-2
baseq$edu4[baseq$edu8==6] <-3
baseq$edu4[baseq$edu8==7] <-4
baseq$edu4[baseq$edu4==0] <-NA #undefined rows are coded as NA so they can be subsequently removed

##new married variable is binary
baseq$married2 <- rep(0, dim(baseq)[1])
baseq$married2[baseq$married7==0] <- 0 #married
baseq$married2[baseq$married7!=0] <- 1 #not married

#new couple variable puts those who are married or had the same partner for at least 1 year
baseq$couple2 <- rep(0, dim(baseq)[1])
baseq$couple2[baseq$married7==0 | baseq$married7==1] <- 0 #couple
baseq$couple2[baseq$married7!=0 & baseq$married7!=1] <- 1 #not couple

##new living status variable is binary
baseq$living.status2 <- rep(0, dim(baseq)[1])
baseq$living.status2[baseq$living.status5==2] <- 0 #live with partner
baseq$living.status2[baseq$living.status5!=2] <- 1 #dont live with partner

##new income variable has 4 levels
baseq$income4 <- rep(0, dim(baseq)[1])
baseq$income4[baseq$income12==0 | baseq$income12==1 | baseq$income12==2 | baseq$income12==3] <-1
baseq$income4[baseq$income12==4 | baseq$income12==5 | baseq$income12==6 | baseq$income12==7] <-2
baseq$income4[baseq$income12==8] <-3
baseq$income4[baseq$income12==9] <-4
baseq$income4[baseq$income4==0] <-NA #undefined rows (income12==98 or 99) are coded as NA, and will be subsequently removed. 

##new mom's birthplace variable is binary
baseq$mom.birthplace2 <- rep(0, dim(baseq)[1])
baseq$mom.birthplace2[baseq$mom.birthplace5==1] <- 0 #born in Canada
baseq$mom.birthplace2[baseq$mom.birthplace5!=1] <- 1 #born outside of Canada

baseq[1:10,] #working - yup -AY
```

```{r mom data}
####Prepare Mother's Data

#Eliminate unnecessary columns: 
mom.data <-mom.data %>%
select("SUBJECT_ID", "PreBMI", "PreBMI_G_dv", "parity_G_dv", "active_smokev1_dv", "alcohol_dv") #active_smokev1_dv refers to a mother's smoker status at visit one (which occurs during the first trimester) # renamed stuff, removed num_babies_dv to match

##Rename columns
colnames(mom.data) <- c("subject.id", "prepreg.bmi", "prepreg.bmi4", "parity4", "smoker4", "alc")

#Redefine the 'prepreg.bmi4' variable so that the range of values is 1:4, not 0:3 (more consistent with how everything else is coded.)
mom.data$prepreg.bmi4[mom.data$prepreg.bmi4==3] <- 4
mom.data$prepreg.bmi4[mom.data$prepreg.bmi4==2] <- 3
mom.data$prepreg.bmi4[mom.data$prepreg.bmi4==1] <- 2
mom.data$prepreg.bmi4[mom.data$prepreg.bmi4==0] <- 1

#make obese2 variable
mom.data$obese2 <- rep(NA, dim(mom.data)[1])
mom.data$obese2[mom.data$prepreg.bmi < 30] <- 2 
mom.data$obese2[mom.data$prepreg.bmi >= 30] <- 1 #equals 1 if BMI >= 30
mom.data$obese2[mom.data$obese2 == 0] <- NA #everyone else is an NA. Code these rows as NA. 
mom.data$obese2[mom.data$prepreg.bmi < 30] <- 0

#Change the levels of the 'smoker4' column from strings to numbers to allow for easier analysis. 
mom.data$smoker4[mom.data$smoker4== "Never"] <- 1
mom.data$smoker4[mom.data$smoker4== "Quit during Pregnancy"] <- 2
mom.data$smoker4[mom.data$smoker4== "Former"] <- 3
mom.data$smoker4[mom.data$smoker4== "Current"] <- 4
mom.data$smoker4[mom.data$smoker4==''] <- NA # Make rows which are blank in the smoker4 column coded as NA, so they can be subsequently removed.
#make this variable numeric, not coded with characters 
mom.data$smoker4 <- as.numeric(mom.data$smoker4)

#Make a binary version of the smoker variable.
mom.data$smoker2 <- rep(0, dim(mom.data)[1])
mom.data$smoker2[mom.data$smoker4== 1 | mom.data$smoker4== 3] <- 0
mom.data$smoker2[mom.data$smoker4== 2 | mom.data$smoker4== 4] <- 1
mom.data$smoker2[is.na(mom.data$smoker4)] <- NA

#Make a binary version of the alc (alcohol/ drank during pregnancy) variable
mom.data$alc2 <-rep(0,dim(mom.data)[1])
mom.data$alc2[mom.data$alc == 0] <- 2
mom.data$alc2[mom.data$alc > 0] <- 1
mom.data$alc2[mom.data$alc2 == 0] <- NA #make undefined rows coded as NA instead of '0', so I can proceed with the next step:
mom.data$alc2[mom.data$alc2 == 2] <- 0 #Non-drinkers are coded as zero 

#change the levels of the parity4 variable such that the values range from 1-4, not 0-3 
mom.data$parity4[mom.data$parity4 == "3+"] <- 4
mom.data$parity4[mom.data$parity4 == "2"] <- 3
mom.data$parity4[mom.data$parity4 == "1"] <- 2
mom.data$parity4[mom.data$parity4 == "0"] <- 1
#Make the levels of parity4 numeric, not characters
mom.data$parity4 <- as.numeric(mom.data$parity4) 

#merge baseq, mom.data, fol.data, home.data; order them alphabetically
mom.data <- merge(baseq,mom.data,by="subject.id", all.x=TRUE)
# mom.data <- merge(mom.data, fol.data,by="subject.id", all.x=TRUE) # no folate data for now -AY
#mom.data <- merge(mom.data, home.data,by="subject.id", all.x=TRUE)

mom.data <- mom.data[,c("subject.id", "alc", "alc2", "city10", "couple2", "edu4", "edu8", "income4", "income12", "living.status2", "living.status5", "married2", "married7", "mom.age", "mom.age3", "mom.birthplace2", "mom.birthplace5","obese2", "parity4", "prepreg.bmi", "prepreg.bmi4", "race.aboriginal2", "race.asian2", "race.black2", "race.latin2", "race.other2", "race.white2", "site11", "smoker2", "smoker4")] # removed fol2

mom.data[1:10,]

##Included both the continuous and categorical versions of the bmi variables
#end users may choose to remove more columns during the analysis stage
```

```{r step 3 put it together}
####Step 3: Combine the cleaned Questionnaire, Neural Development, Mother data, and Baby Data files 
temp <- merge(baby.data,ndev,by="subject.id", all.x=TRUE) 
temp <- merge(temp,mom.data,by="subject.id", all.x=TRUE) 
demog <- temp

#Fix how some categorical variables are coded
##categorical variables with >2 levels are currently coded as "doubles", which can cause problem during their analysis. Will code them as "factors"
attach(demog)
demog$city10 <- as.factor(city10)
demog$edu4 <- as.factor(edu4)
demog$edu8 <- as.factor(edu8)
demog$income4 <- as.factor(income4)
demog$income12 <- as.factor(income12)
demog$living.status5 <- as.factor(living.status5)
demog$married7 <- as.factor(married7)
demog$mom.birthplace5 <- as.factor(mom.birthplace5)
demog$parity4 <- as.factor(parity4)
demog$prepreg.bmi4 <- as.factor(prepreg.bmi4)
demog$site11 <- as.factor(site11)
demog$smoker4 <- as.factor(smoker4)
detach(demog)

# Removing missing FSIQ, PIQ, or VIQ values:
demog <- filter(demog, !is.na(fsiq) & !is.na(piq) & !is.na(viq))

write.table(demog, file="~/Desktop/Cleaned Data/Demographics June 15.csv", sep=",", row.names = FALSE)

```
#################################################
#####Part 2
#################################################

```{r step 1}
####Step 1: Initial set up

#set a seed so results will be exactly the same each time the code is run
set.seed(1010)

#note that data was loaded in part 1. 

## rename column names for clarity
colnames(labres)[2]<- "subject.id"
colnames(labres)[5]<- "test.name"
colnames(labres)[6]<- "test.result"

##Remove unnecessary columns in labres (only useful variables are retained)
labrescol <- c("subject.id", "test.name", "test.result") 
labres<-labres[labrescol]

#Make variable for the time (trimester) with which the lab test was done:
labres$test.time <- substr(labres$subject.id,8,8) #The value of this new variable is equal to the 8th character of the 'specimen.bar.code' string. 

##Extract the first 6 characters from each 'specimen.bar.code' string to get the subject ID for a given row. 
labres$subject.id <- substr(labres$subject.id,1,6)

## Removing missing values: "other", "NR" (no response), "NSQ" (not sampled), "Dam" (unsure of what it means) 
#controls: find length before removing. 
length(labres$test.result[labres$test.result=="Other"])
length(labres$test.result[labres$test.result=="NR"])
length(labres$test.result[labres$test.result=="NSQ"])
length(labres$test.result[labres$test.result=="Dam"])

labres <- labres %>% 
filter(labres$test.result!="Other" & labres$test.result!="NR" & labres$test.result!="NSQ" & labres$test.result!="Dam")

length(labres$test.result[labres$test.result=="Other"])
length(labres$test.result[labres$test.result=="NR"])
length(labres$test.result[labres$test.result=="NSQ"])
length(labres$test.result[labres$test.result=="Dam"]) #proves that code removed the 4 sources of listed values 

#Check to see if everything is working as expected so far:
labres[labres$test.name=="COTISE",] 
#Results are expected, as:
##the below LOD (<) values are retained, and the values above the LOD are behaving normally. 
##the test.time variable is amended to the labres dataframe
##the subject.id column is behaving as expected

#Notice that in the cotise lab results, there are 2 LODs: 0.4 and 0.005. Because of this, I this chemical was used as an example throughout. 
```

```{r step 2}
####Step 2: 'Flag' all test result values that are below the LOD, and remove the '<' from lab result values which are below the LOD. 

### heavily edited for time, see original code for how Josh did it - AY

# Test for comparison later: 
labres[labres$test.name=="BPC170PL",] #test - note how the 6th is below the LOD
labres[labres$test.name=="COTISE",] #test - everything in the first group should be below LOD

# flagging anything below LOD (if the test.result starts with "<", the flag = 1)
labres <- mutate(labres, lod.flag = ifelse((substr(labres$test.result,1,1) == "<"), 1, 0))

# removing the "<" (this code actually removes all symbols except for ".") 
labres$test.result <- str_replace_all(labres$test.result, "[^[:alnum:]\\.\\s]","")

#
labres[labres$test.name=="BPC170PL",] #test
labres[labres$test.name=="COTISE",] #test
# Seems to work ok - everything that was below the LOD is flagged and has the "<" removed

# Note: if you run this again without running from the top the flags go away and the rest of the code won't work - AY
```

```{r step 3}
####Step 3: Dividing test results below the LOD by sqrt(2)

#Lab result values are saved as characters, which cannot be transformed (cannot find (value)/sqrt(2))
## We must convert test.results values to 'doubles' (dbl)
labres$test.result <- as.numeric(labres$test.result)

labres$test.result <- ifelse(labres$lod.flag==1, labres$test.result/sqrt(2), labres$test.result) #IF a row is'flagged'(ie. lod.flag ==1), replace its test.result value with LOD/ sqrt(2). Otherwise, keep the test.result value as is. 

labres[labres$test.name=="BPC170PL",] #Confirms that test.result values which are flagged are divided by sqrt(2), and non-flagged rows are not effected.

#Note/ rationale for this step
## We are making our best guess as to what the chemical concentrations are for the below LOD participants by assuming that chemical exposure is normally distributed and assigning everyone with a below LOD value a test.result value of LOD/sqrt(2).
##Otherwise, we could exclude the below LOD people from the mean, sd calculation in step 5. Doing so would introduce a lot of bias. 
```

```{r step 4}
####Step 4: Make a new column in the labres dataframe representing the log (base 2) of the test results data
labres <-mutate(labres, log2.test.result = log2(labres$test.result)) 

#check to see that it worked
labres[labres$test.name=="BPC170PL",] #New column appears to be functional 
```

```{r step 5}
####Step 5: Making a new dataframe (called 'LODmeansd.all') containing log2(mean) and log2(sd). This information is essential for later use in imputation function. 
#the log2(mean) and log2(sd) values considers rows which are below the LOD as a result of step 3. 

labres %>% 
group_by(test.name) %>% 
summarise(meanlog2 = mean(log2.test.result, na.rm= TRUE), sdlog2 = sd(log2.test.result, na.rm=TRUE)) -> LODmeansd.all 
#LODmeansd is a new dataframe with 3 columns: test.name, meanlog2, sdlog2. 

LODmeansd.all #check
#Confirms that the new dataframe contains meanlog2 and sdlog2 values for each chemical.
```

```{r step 6}
####Step 6: Undo step 3

#fix test.result values for flagged rows:
labres$test.result <- ifelse(labres$lod.flag==1, labres$test.result*(2/sqrt(2)), labres$test.result) #IF a row is 'flagged' (ie lod.flag ==1), replace its test.result value with LOD*(2/sqrt(2)), which undoes step 3. If a row is not flagged, keep the test.result value as is. 

#fix log2.test.results for flagged rows:
labres$log2.test.result <- log2(labres$test.result) 

#Check to see that it worked:
labres[labres$test.name=="BPC170PL",] 
#test.result values that are flagged now have their originalvalues, as flagged rows have a test.result value == 0.01, which is the only LOD for pcb170. 
#The log2.test.result values for flagged rows are also normal again. 

#This step is necessary because I will need to have the correct test.result value in flagged rows. If not, there will be problems in step 8. As we will see, the test.result value is the upper limit for imputation, so if the test.result value is wrong, imputation will be wrong. 

```

```{r step7}
####Step 7: Prepare the 'fLOD' function, which used for imputation in step 8

fLOD <- function(test.result, meanlog2, sdlog2){ ##Create a new function, fLOD, which needs 3 inputs: the LOD value (represented by labres$test.result in FLAGGED rows); the mean (meanlog2); the sd (sdlog2)
impute <- rtruncnorm(1, b=log2(test.result), mean=meanlog2, sd=sdlog2) #the function will then run the rtruncnorm command given the inputs (eg. b= upper limit = log2(LOD), mean, and sd) 
return(impute) 
}
```

```{r step 8 cot}

####Step 8: Complete the imputation process for a particular chemical: cotinine
summary(labres$test.result[labres$test.name=="COTISE"]) #control: see that the minimum value is 0.005 ug/L (or 5 ng/L), which is the lowest LOD. 

#make a new dataframe, 'cot', which only contains data on cotinine
cot <- labres %>%
filter(labres$test.name == "COTISE")

#make a new variable, log2.imputed
#If the test expression 'cot$lod.flag==1' is TRUE for a given row, we apply the fLOD function (gives the row a log2.imputed value less than the LOD, based on a distribution with mean, sd calculated in step 5). 
#If the test expression is FALSE, we do not apply the function, and nothing happens (so the original log2.test.result value will be stored in log2.imputed)
cot <- cot %>%
mutate(log2.imputed = ifelse(cot$lod.flag==1, apply(cot, MARGIN=1, FUN = function(x) fLOD(cot$test.result, LODmeansd.all$meanlog2[LODmeansd.all$test.name == "COTISE"], LODmeansd.all$sdlog2[LODmeansd.all$test.name == "COTISE"])), cot$log2.test.result))

#make a new variable, cot.result, which undoes the log2 to get a result we can work with. 
cot <- cot %>%
mutate(cot.res = 2^(cot$log2.imputed))
#Convert log2(result) to result (for easier interpretation)

#Check that step 8 worked:
cot 
#For flagged rows (subject below LOD), log2.test.result does NOT equall log2.imputed, meaning that flagged rows were assigned a value based on the imputation function, as expected. 
#For non-flagged rows (subject above LOD), log2.test.result = log2.imputed, so no imputation occured on rows above the LOD (as expected).

summary(cot$cot.res[cot$lod.flag==1]) 
#See that the maximum value *among imputed rows* is 391.9628 ng/L (0r 0.391 ug/L), which is slightly less than the highest LOD. Thus the range looks good, as no imputed rows should have a value greater than the LOD.

summary(cot$cot.res[cot$lod.flag==0])
#see that the minumum value among *non-imputed rows* (because lod.flag = 0, meaning that the subject is above the LOD) was 5 ng/L (or 0.005 ug/L), which is equal to the lowest LOD. Thus the range looks good, because non-imputed rows should not have a value less than the LOD. 

```

```{r step 9 cot}
####Step 9: Make time and chemical-specific data frames with 3 columns: subject.id, imputed lab result value, andlod.flag

#first see which time points had serum-cotinine tests done (to check if subsequent steps are working)
#table(cot$test.time) #test done during the 1st and 3rd trimesters (t1 and t3 respectively), and post-birth (t4). 1940 subjects tested during tri1, 1685 subjects tested during tri3, 1385 subjects tested post-birth

#Make time point-specific dataframes with 3 columns
cot.t1 <- filter(cot, cot$test.time == 1) #make a new dataframe, cot.t1, which only has has results for tests done in the first trimester

#Remove unnecessary columns
cot.t1.col <- c("subject.id", "lod.flag", "cot.res")
cot.t1 <- cot.t1[cot.t1.col] 

#Remane the columns so that the name is specific to the test time, chemical being tested
colnames(cot.t1) <- c("subject.id", "cot.t1.flag", "cot.t1.res")

#Check
cot.t1 
#dataframe has 1940 rows, as expected
#Only the necessary columns remain, and all columns have specific names. 

#Make time point-specific dataframes with 3 columns
cot.t3 <- filter(cot, cot$test.time == 3) #make a new dataframe, cot.t3, which only has has results for tests done in the first trimester

#Remove unnecessary columns
cot.t3.col <- c("subject.id", "lod.flag", "cot.res")
cot.t3 <- cot.t3[cot.t3.col] 

#Remane the columns so that the name is specific to the test time, chemical being tested
colnames(cot.t3) <- c("subject.id", "cot.t3.flag", "cot.t3.res")

#Check
cot.t3 
#dataframe has 1685 rows, as expected
#Only the necessary columns remain, and all columns have specific names. 

#Make time point-specific dataframes with 3 columns
cot.t4 <- filter(cot, cot$test.time == 4) #make a new dataframe, cot.t4, which only has has results for tests done in the first trimester

#Remove unnecessary columns
cot.t4.col <- c("subject.id", "lod.flag", "cot.res")
cot.t4 <- cot.t4[cot.t4.col] 

#Remane the columns so that the name is specific to the test time, chemical being tested
colnames(cot.t4) <- c("subject.id", "cot.t4.flag", "cot.t4.res")

#Check
cot.t4 #dataframe has 1385 rows, as expected
#Only the necessary columns remain, and all columns have specific names. 

rm(cot.t1.col, cot.t3.col, cot.t4.col, cot) #clean up the environment as we go. 
```

```{r step 8-9 all}
####Repeat steps 8-9 for all chemicals, the "adjustors"

#start with the 3 "Adjustors" (lipid concentration in the blood, creatine concentration in the urine, specific gravity of the urine)

####Step 8: Complete the imputation process for a plasma-lipid levels
table(labres$lod.flag[labres$test.name=="LIPIPL" & labres$test.time==1]) #No rows are flagged, so technically, step 9 (imputation is not necessary, but I will run step 9 anyways (nothing will happen))

lipid <- labres %>%
filter(labres$test.name == "LIPIPL")
lipid <- lipid %>%
mutate(log2.imputed = ifelse(lipid$lod.flag ==1, apply(lipid, MARGIN=1, FUN = function(x) fLOD(lipid$test.result, LODmeansd.all$meanlog2[LODmeansd.all$test.name == "LIPIPL"], LODmeansd.all$sdlog2[LODmeansd.all$test.name == "LIPIPL"])), lipid$log2.test.result))
lipid <- lipid %>%
mutate(lipid.res = 2^(lipid$log2.imputed)) #Convert log2(imputed lab result) to result (for easier interpretation)

####Step 9: Make time and chemical-specific dataframes with 3 rows: subject.id, imputed lab result value, andlod.flag
lipid.t1 <- filter(lipid, lipid$test.time == 1) ##Dataframe only contains data from t1 (first trimester of pregnancy)
lipid.t1.col <- c("subject.id", "lod.flag", "lipid.res")
lipid.t1 <- lipid.t1[lipid.t1.col] #Only useful columns are retained 
colnames(lipid.t1) <- c("subject.id", "lipid.t1.flag", "lipid.t1.res") #rename the remaining columns so that the column names are chemical, time specific 
lipid.t1 #Only the necessary columns for filling in table 2 remain, and these 2 columns have specific names. 

rm(lipid.t1.col, lipid) #clean up the environment as we go

####Repeat steps 8-9 for creatinine
####Step 8: Complete the imputation process for creatinine
cre <- labres %>%
filter(labres$test.name == "CRE")
cre <- cre %>%
mutate(log2.imputed = ifelse(cre$lod.flag ==1, apply(cre, MARGIN=1, FUN = function(x) fLOD(cre$test.result, LODmeansd.all$meanlog2[LODmeansd.all$test.name == "CRE"], LODmeansd.all$sdlog2[LODmeansd.all$test.name == "CRE"])), cre$log2.test.result))
cre <- cre %>%
mutate(cre.res = 2^(cre$log2.imputed)) #Convert log2(imputed lab result) to result (for easier interpretation)

####Step 9: Make time and chemical-specific dataframes with 3 rows: subject.id, imputed lab result value, andlod.flag
cre.t1 <- filter(cre, cre$test.time == 1) ##Dataframe only contains data from t1 (first trimester of pregnancy)
cre.t1.col <- c("subject.id", "lod.flag", "cre.res")
cre.t1 <- cre.t1[cre.t1.col] #Only useful columns are retained 
colnames(cre.t1) <- c("subject.id", "cre.t1.flag", "cre.t1.res") #rename the remaining columns so that the column names are chemical, time specific 
cre.t1 #Only the necessary columns for filling in table 2 remain, and these 2 columns have specific names. 

rm(cre.t1.col, cre) #clean up the environment as we go

####Repeat steps 8-9 for specific Gravity (SG)
####Step 8: Complete the imputation process for creatinine
sg <- labres %>%
filter(labres$test.name == "DENS")
sg <- sg %>%
mutate(log2.imputed = ifelse(sg$lod.flag ==1, apply(sg, MARGIN=1, FUN = function(x) fLOD(sg$test.result, LODmeansd.all$meanlog2[LODmeansd.all$test.name == "DENS"], LODmeansd.all$sdlog2[LODmeansd.all$test.name == "DENS"])), sg$log2.test.result))
sg <- sg %>%
mutate(sg.res = 2^(sg$log2.imputed)) #Convert log2(imputed lab result) to result (for easier interpretation)

####Step 9: Make time and chemical-specific dataframes with 3 rows: subject.id, imputed lab result value, andlod.flag
sg.t1 <- filter(sg, sg$test.time == 1) ##Dataframe only contains data from t1 (first trimester of pregnancy)
sg.t1.col <- c("subject.id", "lod.flag", "sg.res")
sg.t1 <- sg.t1[sg.t1.col] #Only useful columns are retained 
colnames(sg.t1) <- c("subject.id", "sg.t1.flag", "sg.t1.res") #rename the remaining columns so that the column names are chemical, time specific 
sg.t1 #Only the necessary columns for filling in table 2 remain, and these 2 columns have specific names. 

rm(sg.t1.col, sg) #clean up the environment as we go

####Step 8: Complete imputation for a particular chemical
arsenic <- labres %>%
filter(labres$test.name == "ASSG")
arsenic <- arsenic %>%
mutate(log2.imputed = ifelse(arsenic$lod.flag ==1, apply(arsenic, MARGIN=1, FUN = function(x) fLOD(arsenic$test.result, LODmeansd.all$meanlog2[LODmeansd.all$test.name == "ASSG"], LODmeansd.all$sdlog2[LODmeansd.all$test.name == "ASSG"])), arsenic$log2.test.result))
arsenic <- arsenic %>%
mutate(arsenic.res = 2^(arsenic$log2.imputed)) #Convert log2(imputed lab result) to result (for easier interpretation)

####Step 9: Make time and chemical-specific dataframes with 3 rows: subject.id, imputed lab result value, andlod.flag
arsenic.t1 <- filter(arsenic, arsenic$test.time == 1) ##Dataframe only contains data from t1 (first trimester of pregnancy)
arsenic.t1.col <- c("subject.id", "lod.flag", "arsenic.res")
arsenic.t1 <- arsenic.t1[arsenic.t1.col] #Only useful columns are retained 
colnames(arsenic.t1) <- c("subject.id", "arsenic.t1.flag", "arsenic.t1.res") #rename the remaining columns so that the column names are chemical, time specific 

rm(arsenic.t1.col, arsenic) #clean up the environment as we go

####Step 8: Complete imputation for a particular chemical
cadmium <- labres %>%
filter(labres$test.name == "CDSG")
cadmium <- cadmium %>%
mutate(log2.imputed = ifelse(cadmium$lod.flag ==1, apply(cadmium, MARGIN=1, FUN = function(x) fLOD(cadmium$test.result, LODmeansd.all$meanlog2[LODmeansd.all$test.name == "CDSG"], LODmeansd.all$sdlog2[LODmeansd.all$test.name == "CDSG"])), cadmium$log2.test.result))
cadmium <- cadmium %>%
mutate(cadmium.res = 2^(cadmium$log2.imputed)) #Convert log2(result) to result (for easier interpretation)

####Step 9: Make time and chemical-specific data frames with 3 columns: subject.id, imputed lab result value, andlod.flag
cadmium.t1 <- filter(cadmium, cadmium$test.time == 1) ##Dataframe only contains data from t1 (first trimester of pregnancy)
cadmium.t1.col <- c("subject.id", "lod.flag", "cadmium.res")
cadmium.t1 <- cadmium.t1[cadmium.t1.col] #Only useful columns are retained 
colnames(cadmium.t1) <- c("subject.id", "cadmium.t1.flag", "cadmium.t1.res") #rename the remaining columns so that the column names are chemical, time specific 

rm(cadmium.t1.col, cadmium) #clean up the environment as we go

####Step 8: Complete imputation for a particular chemical
mercury <- labres %>%
filter(labres$test.name == "HGSG")
mercury <- mercury %>%
mutate(log2.imputed = ifelse(mercury$lod.flag ==1, apply(mercury, MARGIN=1, FUN = function(x) fLOD(mercury$test.result, LODmeansd.all$meanlog2[LODmeansd.all$test.name == "HGSG"], LODmeansd.all$sdlog2[LODmeansd.all$test.name == "HGSG"])), mercury$log2.test.result))
mercury <- mercury %>%
mutate(mercury.res = 2^(mercury$log2.imputed)) #Convert log2(result) to result (for easier interpretation)

####Step 9: Make time and chemical-specific data frames with 3 columns: subject.id, imputed lab result value, andlod.flag
mercury.t1 <- filter(mercury, mercury$test.time == 1) ##Dataframe only contains data from t1 (first trimester of pregnancy)
mercury.t1.col <- c("subject.id", "lod.flag", "mercury.res")
mercury.t1 <- mercury.t1[mercury.t1.col] #Only useful columns are retained 
colnames(mercury.t1) <- c("subject.id", "mercury.t1.flag", "mercury.t1.res") #rename the remaining columns so that the column names are chemical, time specific 

rm(mercury.t1.col, mercury) #clean up the environment as we go

####Step 8: Complete imputation for a particular chemical
manganese <- labres %>%
filter(labres$test.name == "MNSG")
manganese <- manganese %>%
mutate(log2.imputed = ifelse(manganese$lod.flag ==1, apply(manganese, MARGIN=1, FUN = function(x) fLOD(manganese$test.result, LODmeansd.all$meanlog2[LODmeansd.all$test.name == "MNSG"], LODmeansd.all$sdlog2[LODmeansd.all$test.name == "MNSG"])), manganese$log2.test.result))
manganese <- manganese %>%
mutate(manganese.res = 2^(manganese$log2.imputed)) #Convert log2(result) to result (for easier interpretation)

####Step 9: Make time and chemical-specific data frames with 3 columns: subject.id, imputed lab result value, andlod.flag
manganese.t1 <- filter(manganese, manganese$test.time == 1) ##Dataframe only contains data from t1 (first trimester of pregnancy)
manganese.t1.col <- c("subject.id", "lod.flag", "manganese.res")
manganese.t1 <- manganese.t1[manganese.t1.col] #Only useful columns are retained 
colnames(manganese.t1) <- c("subject.id", "manganese.t1.flag", "manganese.t1.res") #rename the remaining columns so that the column names are chemical, time specific 

rm(manganese.t1.col, manganese) #clean up the environment as we go

####Step 8: Complete imputation for a particular chemical
lead <- labres %>%
filter(labres$test.name == "PBSG")
lead <- lead %>%
mutate(log2.imputed = ifelse(lead$lod.flag ==1, apply(lead, MARGIN=1, FUN = function(x) fLOD(lead$test.result, LODmeansd.all$meanlog2[LODmeansd.all$test.name == "PBSG"], LODmeansd.all$sdlog2[LODmeansd.all$test.name == "PBSG"])), lead$log2.test.result))
lead <- lead %>%
mutate(lead.res = 2^(lead$log2.imputed)) 
#Convert log2(result) to result (for easier interpretation)

####Step 9: Make time and chemical-specific data frames with 3 columns: subject.id, imputed lab result value, andlod.flag
lead.t1 <- filter(lead, lead$test.time == 1) ##Dataframe only contains data from t1 (first trimester of pregnancy)
lead.t1.col <- c("subject.id", "lod.flag", "lead.res")
lead.t1 <- lead.t1[lead.t1.col] #Only useful columns are retained 
colnames(lead.t1) <- c("subject.id", "lead.t1.flag", "lead.t1.res") #rename the remaining columns so that the column names are chemical, time specific 

rm(lead.t1.col, lead) #clean up the environment as we go

#OC pesticides
####Step 8: Complete imputation for a particular chemical
bbhc <- labres %>%
filter(labres$test.name == "BBHCPL")
bbhc <- bbhc %>%
mutate(log2.imputed = ifelse(bbhc$lod.flag ==1, apply(bbhc, MARGIN=1, FUN = function(x) fLOD(bbhc$test.result, LODmeansd.all$meanlog2[LODmeansd.all$test.name == "BBHCPL"], LODmeansd.all$sdlog2[LODmeansd.all$test.name == "BBHCPL"])), bbhc$log2.test.result))
bbhc <- bbhc %>%
mutate(bbhc.res = 2^(bbhc$log2.imputed)) 
#Convert log2(result) to result (for easier interpretation)

####Step 9: Make time and chemical-specific data frames with 3 columns: subject.id, imputed lab result value, andlod.flag
bbhc.t1 <- filter(bbhc, bbhc$test.time == 1) ##Dataframe only contains data from t1 (first trimester of pregnancy)
bbhc.t1.col <- c("subject.id", "lod.flag", "bbhc.res")
bbhc.t1 <- bbhc.t1[bbhc.t1.col] #Only useful columns are retained 
colnames(bbhc.t1) <- c("subject.id", "bbhc.t1.flag", "bbhc.t1.res") #rename the remaining columns so that the column names are chemical, time specific 

rm(bbhc.t1.col, bbhc) #clean up the environment as we go

####Step 8: Complete imputation for a particular chemical
dde <- labres %>%
filter(labres$test.name == "DDEPL")
dde <- dde %>%
mutate(log2.imputed = ifelse(dde$lod.flag ==1, apply(dde, MARGIN=1, FUN = function(x) fLOD(dde$test.result, LODmeansd.all$meanlog2[LODmeansd.all$test.name == "DDEPL"], LODmeansd.all$sdlog2[LODmeansd.all$test.name == "DDEPL"])), dde$log2.test.result))
dde <- dde %>%
mutate(dde.res = 2^(dde$log2.imputed)) 
#Convert log2(result) to result (for easier interpretation)

####Step 9: Make time and chemical-specific data frames with 3 columns: subject.id, imputed lab result value, andlod.flag
dde.t1 <- filter(dde, dde$test.time == 1) ##Dataframe only contains data from t1 (first trimester of pregnancy)
dde.t1.col <- c("subject.id", "lod.flag", "dde.res")
dde.t1 <- dde.t1[dde.t1.col] #Only useful columns are retained 
colnames(dde.t1) <- c("subject.id", "dde.t1.flag", "dde.t1.res") #rename the remaining columns so that the column names are chemical, time specific 

rm(dde.t1.col, dde) #clean up the environment as we go

####Step 8: Complete imputation for a particular chemical
oxychlor <- labres %>%
filter(labres$test.name == "OXYCHLORPL")
oxychlor <- oxychlor %>%
mutate(log2.imputed = ifelse(oxychlor$lod.flag ==1, apply(oxychlor, MARGIN=1, FUN = function(x) fLOD(oxychlor$test.result, LODmeansd.all$meanlog2[LODmeansd.all$test.name == "OXYCHLORPL"], LODmeansd.all$sdlog2[LODmeansd.all$test.name == "OXYCHLORPL"])), oxychlor$log2.test.result))
oxychlor <- oxychlor %>%
mutate(oxychlor.res = 2^(oxychlor$log2.imputed)) 
#Convert log2(result) to result (for easier interpretation)

####Step 9: Make time and chemical-specific data frames with 3 columns: subject.id, imputed lab result value, andlod.flag
oxychlor.t1 <- filter(oxychlor, oxychlor$test.time == 1) ##Dataframe only contains data from t1 (first trimester of pregnancy)
oxychlor.t1.col <- c("subject.id", "lod.flag", "oxychlor.res")
oxychlor.t1 <- oxychlor.t1[oxychlor.t1.col] #Only useful columns are retained 
colnames(oxychlor.t1) <- c("subject.id", "oxychlor.t1.flag", "oxychlor.t1.res") #rename the remaining columns so that the column names are chemical, time specific 

rm(oxychlor.t1.col, oxychlor) #clean up the environment as we go

####Step 8: Complete imputation for a particular chemical
transnona <- labres %>%
filter(labres$test.name == "TRANSNONAPL")
transnona <- transnona %>%
mutate(log2.imputed = ifelse(transnona$lod.flag ==1, apply(transnona, MARGIN=1, FUN = function(x) fLOD(transnona$test.result, LODmeansd.all$meanlog2[LODmeansd.all$test.name == "TRANSNONAPL"], LODmeansd.all$sdlog2[LODmeansd.all$test.name == "TRANSNONAPL"])), transnona$log2.test.result))
transnona <- transnona %>%
mutate(transnona.res = 2^(transnona$log2.imputed)) 
#Convert log2(result) to result (for easier interpretation)

####Step 9: Make time and chemical-specific data frames with 3 columns: subject.id, imputed lab result value, andlod.flag
transnona.t1 <- filter(transnona, transnona$test.time == 1) ##Dataframe only contains data from t1 (first trimester of pregnancy)
transnona.t1.col <- c("subject.id", "lod.flag", "transnona.res")
transnona.t1 <- transnona.t1[transnona.t1.col] #Only useful columns are retained 
colnames(transnona.t1) <- c("subject.id", "transnona.t1.flag", "transnona.t1.res") #rename the remaining columns so that the column names are chemical, time specific 

rm(transnona.t1.col, transnona) #clean up the environment as we go

####OP Pesticides (OPPs)

####Step 8: Complete imputation for a particular chemical
dep <- labres %>%
filter(labres$test.name == "DEPUR")
dep <- dep %>%
mutate(log2.imputed = ifelse(dep$lod.flag ==1, apply(dep, MARGIN=1, FUN = function(x) fLOD(dep$test.result, LODmeansd.all$meanlog2[LODmeansd.all$test.name == "DEPUR"], LODmeansd.all$sdlog2[LODmeansd.all$test.name == "DEPUR"])), dep$log2.test.result))
dep <- dep %>%
mutate(dep.res = 2^(dep$log2.imputed)) #Convert log2(result) to result (for easier interpretation)

####Step 9: Make time and chemical-specific data frames with 3 columns: subject.id, imputed lab result value, andlod.flag
dep.t1 <- filter(dep, dep$test.time == 1) ##Dataframe only contains data from t1 (first trimester of pregnancy)
dep.t1.col <- c("subject.id", "lod.flag", "dep.res")
dep.t1 <- dep.t1[dep.t1.col] #Only useful columns are retained 
colnames(dep.t1) <- c("subject.id", "dep.t1.flag", "dep.t1.res") #rename the remaining columns so that the column names are chemical, time specific 

rm(dep.t1.col, dep) #clean up the environment as we go

####Step 8: Complete imputation for a particular chemical
detp <- labres %>%
filter(labres$test.name == "DETPUR")
detp <- detp %>%
mutate(log2.imputed = ifelse(detp$lod.flag ==1, apply(detp, MARGIN=1, FUN = function(x) fLOD(detp$test.result, LODmeansd.all$meanlog2[LODmeansd.all$test.name == "DETPUR"], LODmeansd.all$sdlog2[LODmeansd.all$test.name == "DETPUR"])), detp$log2.test.result))
detp <- detp %>%
mutate(detp.res = 2^(detp$log2.imputed)) #Convert log2(result) to result (for easier interpretation)

####Step 9: Make time and chemical-specific data frames with 3 columns: subject.id, imputed lab result value, andlod.flag
detp.t1 <- filter(detp, detp$test.time == 1) ##Dataframe only contains data from t1 (first trimester of pregnancy)
detp.t1.col <- c("subject.id", "lod.flag", "detp.res")
detp.t1 <- detp.t1[detp.t1.col] #Only useful columns are retained 
colnames(detp.t1) <- c("subject.id", "detp.t1.flag", "detp.t1.res") #rename the remaining columns so that the column names are chemical, time specific 

rm(detp.t1.col, detp) #clean up the environment as we go

####Step 8: Complete imputation for a particular chemical
dmdtp <- labres %>%
filter(labres$test.name == "DMDTPUR")
dmdtp <- dmdtp %>%
mutate(log2.imputed = ifelse(dmdtp$lod.flag ==1, apply(dmdtp, MARGIN=1, FUN = function(x) fLOD(dmdtp$test.result, LODmeansd.all$meanlog2[LODmeansd.all$test.name == "DMDTPUR"], LODmeansd.all$sdlog2[LODmeansd.all$test.name == "DMDTPUR"])), dmdtp$log2.test.result))
dmdtp <- dmdtp %>%
mutate(dmdtp.res = 2^(dmdtp$log2.imputed)) #Convert log2(result) to result (for easier interpretation)

####Step 9: Make time and chemical-specific data frames with 3 columns: subject.id, imputed lab result value, andlod.flag
dmdtp.t1 <- filter(dmdtp, dmdtp$test.time == 1) ##Dataframe only contains data from t1 (first trimester of pregnancy)
dmdtp.t1.col <- c("subject.id", "lod.flag", "dmdtp.res")
dmdtp.t1 <- dmdtp.t1[dmdtp.t1.col] #Only useful columns are retained 
colnames(dmdtp.t1) <- c("subject.id", "dmdtp.t1.flag", "dmdtp.t1.res") #rename the remaining columns so that the column names are chemical, time specific 

rm(dmdtp.t1.col, dmdtp) #clean up the environment as we go

####Step 8: Complete imputation for a particular chemical
dmp <- labres %>%
filter(labres$test.name == "DMPUR")
dmp <- dmp %>%
mutate(log2.imputed = ifelse(dmp$lod.flag ==1, apply(dmp, MARGIN=1, FUN = function(x) fLOD(dmp$test.result, LODmeansd.all$meanlog2[LODmeansd.all$test.name == "DMPUR"], LODmeansd.all$sdlog2[LODmeansd.all$test.name == "DMPUR"])), dmp$log2.test.result))
dmp <- dmp %>%
mutate(dmp.res = 2^(dmp$log2.imputed)) #Convert log2(result) to result (for easier interpretation)

####Step 9: Make time and chemical-specific data frames with 3 columns: subject.id, imputed lab result value, andlod.flag
dmp.t1 <- filter(dmp, dmp$test.time == 1) ##Dataframe only contains data from t1 (first trimester of pregnancy)
dmp.t1.col <- c("subject.id", "lod.flag", "dmp.res")
dmp.t1 <- dmp.t1[dmp.t1.col] #Only useful columns are retained 
colnames(dmp.t1) <- c("subject.id", "dmp.t1.flag", "dmp.t1.res") #rename the remaining columns so that the column names are chemical, time specific 

rm(dmp.t1.col, dmp) #clean up the environment as we go

####Step 8: Complete imputation for a particular chemical
dmtp <- labres %>%
filter(labres$test.name == "DMTPUR")
dmtp <- dmtp %>%
mutate(log2.imputed = ifelse(dmtp$lod.flag ==1, apply(dmtp, MARGIN=1, FUN = function(x) fLOD(dmtp$test.result, LODmeansd.all$meanlog2[LODmeansd.all$test.name == "DMTPUR"], LODmeansd.all$sdlog2[LODmeansd.all$test.name == "DMTPUR"])), dmtp$log2.test.result))
dmtp <- dmtp %>%
mutate(dmtp.res = 2^(dmtp$log2.imputed)) #Convert log2(result) to result (for easier interpretation)

####Step 9: Make time and chemical-specific data frames with 3 columns: subject.id, imputed lab result value, andlod.flag
dmtp.t1 <- filter(dmtp, dmtp$test.time == 1) ##Dataframe only contains data from t1 (first trimester of pregnancy)
dmtp.t1.col <- c("subject.id", "lod.flag", "dmtp.res")
dmtp.t1 <- dmtp.t1[dmtp.t1.col] #Only useful columns are retained 
colnames(dmtp.t1) <- c("subject.id", "dmtp.t1.flag", "dmtp.t1.res") #rename the remaining columns so that the column names are chemical, time specific 

rm(dmtp.t1.col, dmtp) #clean up the environment as we go

####PCBs

#Note: for all PCBs, the units are changed from ug/L to ng/L to ease analysis

####Step 8: Complete imputation for a particular chemical
aroclor <- labres %>%
filter(labres$test.name == "BPCPL")
aroclor <- aroclor %>%
mutate(log2.imputed = ifelse(aroclor$lod.flag ==1, apply(aroclor, MARGIN=1, FUN = function(x) fLOD(aroclor$test.result, LODmeansd.all$meanlog2[LODmeansd.all$test.name == "BPCPL"], LODmeansd.all$sdlog2[LODmeansd.all$test.name == "BPCPL"])), aroclor$log2.test.result))
aroclor <- aroclor %>%
mutate(aroclor.res = 2^(aroclor$log2.imputed)) 
#Convert log2(result) to result (for easier interpretation)

####Step 9: Make time and chemical-specific data frames with 3 columns: subject.id, imputed lab result value, andlod.flag
aroclor.t1 <- filter(aroclor, aroclor$test.time == 1) ##Dataframe only contains data from t1 (first trimester of pregnancy)
aroclor.t1.col <- c("subject.id", "lod.flag", "aroclor.res")
aroclor.t1 <- aroclor.t1[aroclor.t1.col] #Only useful columns are retained 
colnames(aroclor.t1) <- c("subject.id", "aroclor.t1.flag", "aroclor.t1.res") #rename the remaining columns so that the column names are chemical, time specific 

rm(aroclor.t1.col, aroclor) #clean up the environment as we go

####Step 8: Complete imputation for a particular chemical
pcb118 <- labres %>%
filter(labres$test.name == "BPC118PL")
pcb118 <- pcb118 %>%
mutate(log2.imputed = ifelse(pcb118$lod.flag ==1, apply(pcb118, MARGIN=1, FUN = function(x) fLOD(pcb118$test.result, LODmeansd.all$meanlog2[LODmeansd.all$test.name == "BPC118PL"], LODmeansd.all$sdlog2[LODmeansd.all$test.name == "BPC118PL"])), pcb118$log2.test.result))
pcb118 <- pcb118 %>%
mutate(pcb118.res = 2^(pcb118$log2.imputed)) 
#Convert log2(result) to result (for easier interpretation)

####Step 9: Make time and chemical-specific data frames with 3 columns: subject.id, imputed lab result value, andlod.flag
pcb118.t1 <- filter(pcb118, pcb118$test.time == 1) ##Dataframe only contains data from t1 (first trimester of pregnancy)
pcb118.t1.col <- c("subject.id", "lod.flag", "pcb118.res")
pcb118.t1 <- pcb118.t1[pcb118.t1.col] #Only useful columns are retained 
colnames(pcb118.t1) <- c("subject.id", "pcb118.t1.flag", "pcb118.t1.res") #rename the remaining columns so that the column names are chemical, time specific 

rm(pcb118.t1.col, pcb118) #clean up the environment as we go

####Step 8: Complete imputation for a particular chemical
pcb138 <- labres %>%
filter(labres$test.name == "BPC138PL")
pcb138 <- pcb138 %>%
mutate(log2.imputed = ifelse(pcb138$lod.flag ==1, apply(pcb138, MARGIN=1, FUN = function(x) fLOD(pcb138$test.result, LODmeansd.all$meanlog2[LODmeansd.all$test.name == "BPC138PL"], LODmeansd.all$sdlog2[LODmeansd.all$test.name == "BPC138PL"])), pcb138$log2.test.result))
pcb138 <- pcb138 %>%
mutate(pcb138.res = 2^(pcb138$log2.imputed)) 
#Convert log2(result) to result (for easier interpretation)

####Step 9: Make time and chemical-specific data frames with 3 columns: subject.id, imputed lab result value, andlod.flag
pcb138.t1 <- filter(pcb138, pcb138$test.time == 1) ##Dataframe only contains data from t1 (first trimester of pregnancy)
pcb138.t1.col <- c("subject.id", "lod.flag", "pcb138.res")
pcb138.t1 <- pcb138.t1[pcb138.t1.col] #Only useful columns are retained 
colnames(pcb138.t1) <- c("subject.id", "pcb138.t1.flag", "pcb138.t1.res") #rename the remaining columns so that the column names are chemical, time specific 

rm(pcb138.t1.col, pcb138) #clean up the environment as we go

####Step 8: Complete imputation for a particular chemical
pcb153 <- labres %>%
filter(labres$test.name == "BPC153PL")
pcb153 <- pcb153 %>%
mutate(log2.imputed = ifelse(pcb153$lod.flag ==1, apply(pcb153, MARGIN=1, FUN = function(x) fLOD(pcb153$test.result, LODmeansd.all$meanlog2[LODmeansd.all$test.name == "BPC153PL"], LODmeansd.all$sdlog2[LODmeansd.all$test.name == "BPC153PL"])), pcb153$log2.test.result))
pcb153 <- pcb153 %>%
mutate(pcb153.res = 2^(pcb153$log2.imputed)) 
#Convert log2(result) to result (for easier interpretation)

####Step 9: Make time and chemical-specific data frames with 3 columns: subject.id, imputed lab result value, andlod.flag
pcb153.t1 <- filter(pcb153, pcb153$test.time == 1) ##Dataframe only contains data from t1 (first trimester of pregnancy)
pcb153.t1.col <- c("subject.id", "lod.flag", "pcb153.res")
pcb153.t1 <- pcb153.t1[pcb153.t1.col] #Only useful columns are retained 
colnames(pcb153.t1) <- c("subject.id", "pcb153.t1.flag", "pcb153.t1.res") #rename the remaining columns so that the column names are chemical, time specific 

rm(pcb153.t1.col, pcb153) #clean up the environment as we go

####Step 8: Complete imputation for a particular chemical
pcb170 <- labres %>%
filter(labres$test.name == "BPC170PL")
pcb170 <- pcb170 %>%
mutate(log2.imputed = ifelse(pcb170$lod.flag ==1, apply(pcb170, MARGIN=1, FUN = function(x) fLOD(pcb170$test.result, LODmeansd.all$meanlog2[LODmeansd.all$test.name == "BPC170PL"], LODmeansd.all$sdlog2[LODmeansd.all$test.name == "BPC170PL"])), pcb170$log2.test.result))
pcb170 <- pcb170 %>%
mutate(pcb170.res = 2^(pcb170$log2.imputed)) 
#Convert log2(result) to result (for easier interpretation)

####Step 9: Make time and chemical-specific data frames with 3 columns: subject.id, imputed lab result value, andlod.flag
pcb170.t1 <- filter(pcb170, pcb170$test.time == 1) ##Dataframe only contains data from t1 (first trimester of pregnancy)
pcb170.t1.col <- c("subject.id", "lod.flag", "pcb170.res")
pcb170.t1 <- pcb170.t1[pcb170.t1.col] #Only useful columns are retained 
colnames(pcb170.t1) <- c("subject.id", "pcb170.t1.flag", "pcb170.t1.res") #rename the remaining columns so that the column names are chemical, time specific 

rm(pcb170.t1.col, pcb170) #clean up the environment as we go

####Step 8: Complete imputation for a particular chemical
pcb180 <- labres %>%
filter(labres$test.name == "BPC180PL")
pcb180 <- pcb180 %>%
mutate(log2.imputed = ifelse(pcb180$lod.flag ==1, apply(pcb180, MARGIN=1, FUN = function(x) fLOD(pcb180$test.result, LODmeansd.all$meanlog2[LODmeansd.all$test.name == "BPC180PL"], LODmeansd.all$sdlog2[LODmeansd.all$test.name == "BPC180PL"])), pcb180$log2.test.result))
pcb180 <- pcb180 %>%
mutate(pcb180.res = 2^(pcb180$log2.imputed)) 
#Convert log2(result) to result (for easier interpretation)

####Step 9: Make time and chemical-specific data frames with 3 columns: subject.id, imputed lab result value, andlod.flag
pcb180.t1 <- filter(pcb180, pcb180$test.time == 1) ##Dataframe only contains data from t1 (first trimester of pregnancy)
pcb180.t1.col <- c("subject.id", "lod.flag", "pcb180.res")
pcb180.t1 <- pcb180.t1[pcb180.t1.col] #Only useful columns are retained 
colnames(pcb180.t1) <- c("subject.id", "pcb180.t1.flag", "pcb180.t1.res") #rename the remaining columns so that the column names are chemical, time specific 

rm(pcb180.t1.col, pcb180) #clean up the environment as we go

####Step 8: Complete imputation for a particular chemical
pcb187 <- labres %>%
filter(labres$test.name == "BPC187PL")
pcb187 <- pcb187 %>%
mutate(log2.imputed = ifelse(pcb187$lod.flag ==1, apply(pcb187, MARGIN=1, FUN = function(x) fLOD(pcb187$test.result, LODmeansd.all$meanlog2[LODmeansd.all$test.name == "BPC187PL"], LODmeansd.all$sdlog2[LODmeansd.all$test.name == "BPC187PL"])), pcb187$log2.test.result))
pcb187 <- pcb187 %>%
mutate(pcb187.res = 2^(pcb187$log2.imputed)) 
#Convert log2(result) to result (for easier interpretation)

####Step 9: Make time and chemical-specific data frames with 3 columns: subject.id, imputed lab result value, andlod.flag
pcb187.t1 <- filter(pcb187, pcb187$test.time == 1) ##Dataframe only contains data from t1 (first trimester of pregnancy)
pcb187.t1.col <- c("subject.id", "lod.flag", "pcb187.res")
pcb187.t1 <- pcb187.t1[pcb187.t1.col] #Only useful columns are retained 
colnames(pcb187.t1) <- c("subject.id", "pcb187.t1.flag", "pcb187.t1.res") #rename the remaining columns so that the column names are chemical, time specific 

rm(pcb187.t1.col, pcb187) #clean up the environment as we go

####Phthalates

####Step 8: Complete imputation for a particular chemical
mbp <- labres %>%
filter(labres$test.name == "MBPUR")
mbp <- mbp %>%
mutate(log2.imputed = ifelse(mbp$lod.flag ==1, apply(mbp, MARGIN=1, FUN = function(x) fLOD(mbp$test.result, LODmeansd.all$meanlog2[LODmeansd.all$test.name == "MBPUR"], LODmeansd.all$sdlog2[LODmeansd.all$test.name == "MBPUR"])), mbp$log2.test.result))
mbp <- mbp %>%
mutate(mbp.res = 2^(mbp$log2.imputed)) #Convert log2(result) to result (for easier interpretation)

####Step 9: Make time and chemical-specific data frames with 3 columns: subject.id, imputed lab result value, andlod.flag
mbp.t1 <- filter(mbp, mbp$test.time == 1) ##Dataframe only contains data from t1 (first trimester of pregnancy)
mbp.t1.col <- c("subject.id", "lod.flag", "mbp.res")
mbp.t1 <- mbp.t1[mbp.t1.col] #Only useful columns are retained 
colnames(mbp.t1) <- c("subject.id", "mbp.t1.flag", "mbp.t1.res") #rename the remaining columns so that the column names are chemical, time specific 

rm(mbp.t1.col, mbp) #clean up the environment as we go

####Step 8: Complete imputation for a particular chemical
mbzp <- labres %>%
filter(labres$test.name == "MBzPUR")
mbzp <- mbzp %>%
mutate(log2.imputed = ifelse(mbzp$lod.flag ==1, apply(mbzp, MARGIN=1, FUN = function(x) fLOD(mbzp$test.result, LODmeansd.all$meanlog2[LODmeansd.all$test.name == "MBzPUR"], LODmeansd.all$sdlog2[LODmeansd.all$test.name == "MBzPUR"])), mbzp$log2.test.result))
mbzp <- mbzp %>%
mutate(mbzp.res = 2^(mbzp$log2.imputed)) #Convert log2(result) to result (for easier interpretation)

####Step 9: Make time and chemical-specific data frames with 3 columns: subject.id, imputed lab result value, andlod.flag
mbzp.t1 <- filter(mbzp, mbzp$test.time == 1) ##Dataframe only contains data from t1 (first trimester of pregnancy)
mbzp.t1.col <- c("subject.id", "lod.flag", "mbzp.res")
mbzp.t1 <- mbzp.t1[mbzp.t1.col] #Only useful columns are retained 
colnames(mbzp.t1) <- c("subject.id", "mbzp.t1.flag", "mbzp.t1.res") #rename the remaining columns so that the column names are chemical, time specific 

rm(mbzp.t1.col, mbzp) #clean up the environment as we go

####Step 8: Complete imputation for a particular chemical
mcpp <- labres %>%
filter(labres$test.name == "MCPPUR")
mcpp <- mcpp %>%
mutate(log2.imputed = ifelse(mcpp$lod.flag ==1, apply(mcpp, MARGIN=1, FUN = function(x) fLOD(mcpp$test.result, LODmeansd.all$meanlog2[LODmeansd.all$test.name == "MCPPUR"], LODmeansd.all$sdlog2[LODmeansd.all$test.name == "MCPPUR"])), mcpp$log2.test.result))
mcpp <- mcpp %>%
mutate(mcpp.res = 2^(mcpp$log2.imputed)) #Convert log2(result) to result (for easier interpretation)

####Step 9: Make time and chemical-specific data frames with 3 columns: subject.id, imputed lab result value, andlod.flag
mcpp.t1 <- filter(mcpp, mcpp$test.time == 1) ##Dataframe only contains data from t1 (first trimester of pregnancy)
mcpp.t1.col <- c("subject.id", "lod.flag", "mcpp.res")
mcpp.t1 <- mcpp.t1[mcpp.t1.col] #Only useful columns are retained 
colnames(mcpp.t1) <- c("subject.id", "mcpp.t1.flag", "mcpp.t1.res") #rename the remaining columns so that the column names are chemical, time specific 

rm(mcpp.t1.col, mcpp) #clean up the environment as we go

####Step 8: Complete imputation for a particular chemical
mehhp <- labres %>%
filter(labres$test.name == "MEHHPUR")
mehhp <- mehhp %>%
mutate(log2.imputed = ifelse(mehhp$lod.flag ==1, apply(mehhp, MARGIN=1, FUN = function(x) fLOD(mehhp$test.result, LODmeansd.all$meanlog2[LODmeansd.all$test.name == "MEHHPUR"], LODmeansd.all$sdlog2[LODmeansd.all$test.name == "MEHHPUR"])), mehhp$log2.test.result))
mehhp <- mehhp %>%
mutate(mehhp.res = 2^(mehhp$log2.imputed)) #Convert log2(result) to result (for easier interpretation)

####Step 9: Make time and chemical-specific data frames with 3 columns: subject.id, imputed lab result value, andlod.flag
mehhp.t1 <- filter(mehhp, mehhp$test.time == 1) ##Dataframe only contains data from t1 (first trimester of pregnancy)
mehhp.t1.col <- c("subject.id", "lod.flag", "mehhp.res")
mehhp.t1 <- mehhp.t1[mehhp.t1.col] #Only useful columns are retained 
colnames(mehhp.t1) <- c("subject.id", "mehhp.t1.flag", "mehhp.t1.res") #rename the remaining columns so that the column names are chemical, time specific 

rm(mehhp.t1.col, mehhp) #clean up the environment as we go

####Step 8: Complete imputation for a particular chemical
mehp <- labres %>%
filter(labres$test.name == "MEHPUR")
mehp <- mehp %>%
mutate(log2.imputed = ifelse(mehp$lod.flag ==1, apply(mehp, MARGIN=1, FUN = function(x) fLOD(mehp$test.result, LODmeansd.all$meanlog2[LODmeansd.all$test.name == "MEHPUR"], LODmeansd.all$sdlog2[LODmeansd.all$test.name == "MEHPUR"])), mehp$log2.test.result))
mehp <- mehp %>%
mutate(mehp.res = 2^(mehp$log2.imputed)) #Convert log2(result) to result (for easier interpretation)

####Step 9: Make time and chemical-specific data frames with 3 columns: subject.id, imputed lab result value, andlod.flag
mehp.t1 <- filter(mehp, mehp$test.time == 1) ##Dataframe only contains data from t1 (first trimester of pregnancy)
mehp.t1.col <- c("subject.id", "lod.flag", "mehp.res")
mehp.t1 <- mehp.t1[mehp.t1.col] #Only useful columns are retained 
colnames(mehp.t1) <- c("subject.id", "mehp.t1.flag", "mehp.t1.res") #rename the remaining columns so that the column names are chemical, time specific 

rm(mehp.t1.col, mehp) #clean up the environment as we go

####Step 8: Complete imputation for a particular chemical
meohp <- labres %>%
filter(labres$test.name == "MEOHPUR")
meohp <- meohp %>%
mutate(log2.imputed = ifelse(meohp$lod.flag ==1, apply(meohp, MARGIN=1, FUN = function(x) fLOD(meohp$test.result, LODmeansd.all$meanlog2[LODmeansd.all$test.name == "MEOHPUR"], LODmeansd.all$sdlog2[LODmeansd.all$test.name == "MEOHPUR"])), meohp$log2.test.result))
meohp <- meohp %>%
mutate(meohp.res = 2^(meohp$log2.imputed)) #Convert log2(result) to result (for easier interpretation)

####Step 9: Make time and chemical-specific data frames with 3 columns: subject.id, imputed lab result value, andlod.flag
meohp.t1 <- filter(meohp, meohp$test.time == 1) ##Dataframe only contains data from t1 (first trimester of pregnancy)
meohp.t1.col <- c("subject.id", "lod.flag", "meohp.res")
meohp.t1 <- meohp.t1[meohp.t1.col] #Only useful columns are retained 
colnames(meohp.t1) <- c("subject.id", "meohp.t1.flag", "meohp.t1.res") #rename the remaining columns so that the column names are chemical, time specific 

rm(meohp.t1.col, meohp) #clean up the environment as we go

####Step 8: Complete imputation for a particular chemical
mep <- labres %>%
filter(labres$test.name == "MEPUR")
mep <- mep %>%
mutate(log2.imputed = ifelse(mep$lod.flag ==1, apply(mep, MARGIN=1, FUN = function(x) fLOD(mep$test.result, LODmeansd.all$meanlog2[LODmeansd.all$test.name == "MEPUR"], LODmeansd.all$sdlog2[LODmeansd.all$test.name == "MEPUR"])), mep$log2.test.result))
mep <- mep %>%
mutate(mep.res = 2^(mep$log2.imputed)) #Convert log2(result) to result (for easier interpretation)

####Step 9: Make time and chemical-specific data frames with 3 columns: subject.id, imputed lab result value, andlod.flag
mep.t1 <- filter(mep, mep$test.time == 1) ##Dataframe only contains data from t1 (first trimester of pregnancy)
mep.t1.col <- c("subject.id", "lod.flag", "mep.res")
mep.t1 <- mep.t1[mep.t1.col] #Only useful columns are retained 
colnames(mep.t1) <- c("subject.id", "mep.t1.flag", "mep.t1.res") #rename the remaining columns so that the column names are chemical, time specific 

rm(mep.t1.col, mep) #clean up the environment as we go

# PBDEs:
## I'm most likely only going to use BDE-47, but I will be including every one that has more than 0% rate of detection here so I can find correlation later - AY

####Step 8: Complete imputation for a particular chemical
bde47 <- labres %>%
filter(labres$test.name == "BDE47PL")
bde47 <- bde47 %>%
mutate(log2.imputed = ifelse(bde47$lod.flag ==1, apply(bde47, MARGIN=1, FUN = function(x) fLOD(bde47$test.result, LODmeansd.all$meanlog2[LODmeansd.all$test.name == "BDE47PL"], LODmeansd.all$sdlog2[LODmeansd.all$test.name == "BDE47PL"])), bde47$log2.test.result))
bde47 <- bde47 %>%
mutate(bde47.res = 2^(bde47$log2.imputed)) #Convert log2(result) to result (for easier interpretation)

####Step 9: Make time and chemical-specific data frames with 3 columns: subject.id, imputed lab result value, andlod.flag
bde47.t1 <- filter(bde47, bde47$test.time == 1) ##Dataframe only contains data from t1 (first trimester of pregnancy)
bde47.t1.col <- c("subject.id", "lod.flag", "bde47.res")
bde47.t1 <- bde47.t1[bde47.t1.col] #Only useful columns are retained 
colnames(bde47.t1) <- c("subject.id", "bde47.t1.flag", "bde47.t1.res") #rename the remaining columns so that the column names are chemical, time specific 

rm(bde47.t1.col, bde47) #clean up the environment as we go

####Step 8: Complete imputation for a particular chemical
bde99 <- labres %>%
filter(labres$test.name == "BDE99PL")
bde99 <- bde99 %>%
mutate(log2.imputed = ifelse(bde99$lod.flag ==1, apply(bde99, MARGIN=1, FUN = function(x) fLOD(bde99$test.result, LODmeansd.all$meanlog2[LODmeansd.all$test.name == "BDE99PL"], LODmeansd.all$sdlog2[LODmeansd.all$test.name == "BDE99PL"])), bde99$log2.test.result))
bde99 <- bde99 %>%
mutate(bde99.res = 2^(bde99$log2.imputed)) #Convert log2(result) to result (for easier interpretation)

####Step 9: Make time and chemical-specific data frames with 3 columns: subject.id, imputed lab result value, andlod.flag
bde99.t1 <- filter(bde99, bde99$test.time == 1) ##Dataframe only contains data from t1 (first trimester of pregnancy)
bde99.t1.col <- c("subject.id", "lod.flag", "bde99.res")
bde99.t1 <- bde99.t1[bde99.t1.col] #Only useful columns are retained 
colnames(bde99.t1) <- c("subject.id", "bde99.t1.flag", "bde99.t1.res") #rename the remaining columns so that the column names are chemical, time specific 

rm(bde99.t1.col, bde99) #clean up the environment as we go

####Step 8: Complete imputation for a particular chemical
bde100 <- labres %>%
filter(labres$test.name == "BDE100PL")
bde100 <- bde100 %>%
mutate(log2.imputed = ifelse(bde100$lod.flag ==1, apply(bde100, MARGIN=1, FUN = function(x) fLOD(bde100$test.result, LODmeansd.all$meanlog2[LODmeansd.all$test.name == "BDE100PL"], LODmeansd.all$sdlog2[LODmeansd.all$test.name == "BDE100PL"])), bde100$log2.test.result))
bde100 <- bde100 %>%
mutate(bde100.res = 2^(bde100$log2.imputed)) #Convert log2(result) to result (for easier interpretation)

####Step 9: Make time and chemical-specific data frames with 3 columns: subject.id, imputed lab result value, andlod.flag
bde100.t1 <- filter(bde100, bde100$test.time == 1) ##Dataframe only contains data from t1 (first trimester of pregnancy)
bde100.t1.col <- c("subject.id", "lod.flag", "bde100.res")
bde100.t1 <- bde100.t1[bde100.t1.col] #Only useful columns are retained 
colnames(bde100.t1) <- c("subject.id", "bde100.t1.flag", "bde100.t1.res") #rename the remaining columns so that the column names are chemical, time specific 

rm(bde100.t1.col, bde100) #clean up the environment as we go

####Step 8: Complete imputation for a particular chemical
bde153 <- labres %>%
filter(labres$test.name == "BDE153PL")
bde153 <- bde153 %>%
mutate(log2.imputed = ifelse(bde153$lod.flag ==1, apply(bde153, MARGIN=1, FUN = function(x) fLOD(bde153$test.result, LODmeansd.all$meanlog2[LODmeansd.all$test.name == "BDE153PL"], LODmeansd.all$sdlog2[LODmeansd.all$test.name == "BDE153PL"])), bde153$log2.test.result))
bde153 <- bde153 %>%
mutate(bde153.res = 2^(bde153$log2.imputed)) #Convert log2(result) to result (for easier interpretation)

####Step 9: Make time and chemical-specific data frames with 3 columns: subject.id, imputed lab result value, andlod.flag
bde153.t1 <- filter(bde153, bde153$test.time == 1) ##Dataframe only contains data from t1 (first trimester of pregnancy)
bde153.t1.col <- c("subject.id", "lod.flag", "bde153.res")
bde153.t1 <- bde153.t1[bde153.t1.col] #Only useful columns are retained 
colnames(bde153.t1) <- c("subject.id", "bde153.t1.flag", "bde153.t1.res") #rename the remaining columns so that the column names are chemical, time specific 

rm(bde153.t1.col, bde153) #clean up the environment as we go
```

```{r step 10}
####Step 10: Merge dataframes for chemicals in the same class horizontally
temp <- merge(arsenic.t1,cadmium.t1,by="subject.id", all.x=TRUE) 
temp <- merge(temp,lead.t1,by="subject.id", all.x=TRUE)
temp <- merge(temp,manganese.t1,by="subject.id", all.x=TRUE)
temp <- merge(temp,mercury.t1,by="subject.id", all.x=TRUE)
metal.t1 <-temp
rm(arsenic.t1, cadmium.t1, lead.t1, manganese.t1, mercury.t1) #clean up the environment as we go

temp <- merge(bbhc.t1,dde.t1,by="subject.id", all.x=TRUE) 
temp <- merge(temp,oxychlor.t1,by="subject.id", all.x=TRUE)
temp <- merge(temp,transnona.t1,by="subject.id", all.x=TRUE)
ocp.t1 <-temp

temp <- merge(dep.t1,detp.t1,by="subject.id", all.x=TRUE) 
temp <- merge(temp,dmdtp.t1,by="subject.id", all.x=TRUE)
temp <- merge(temp,dmp.t1,by="subject.id", all.x=TRUE)
temp <- merge(temp,dmtp.t1,by="subject.id", all.x=TRUE)
opp.t1 <-temp
rm(dep.t1, detp.t1, dmdtp.t1, dmp.t1, dmtp.t1) #clean up the environment as we go

temp <- merge(aroclor.t1,pcb118.t1,by="subject.id", all.x=TRUE) 
temp <- merge(temp,pcb138.t1,by="subject.id", all.x=TRUE)
temp <- merge(temp,pcb153.t1,by="subject.id", all.x=TRUE)
temp <- merge(temp,pcb170.t1,by="subject.id", all.x=TRUE)
temp <- merge(temp,pcb180.t1,by="subject.id", all.x=TRUE)
temp <- merge(temp,pcb187.t1,by="subject.id", all.x=TRUE)
pcb.t1 <-temp

temp <- merge(mbp.t1,mbzp.t1,by="subject.id", all.x=TRUE) 
temp <- merge(temp,mcpp.t1,by="subject.id", all.x=TRUE)
temp <- merge(temp,mehhp.t1,by="subject.id", all.x=TRUE)
temp <- merge(temp,mehp.t1,by="subject.id", all.x=TRUE)
temp <- merge(temp,meohp.t1,by="subject.id", all.x=TRUE)
temp <- merge(temp,mep.t1,by="subject.id", all.x=TRUE)
phth.t1 <-temp

temp <- merge(bde47.t1,bde99.t1,by="subject.id", all.x=TRUE) 
temp <- merge(temp,bde100.t1,by="subject.id", all.x=TRUE)
temp <- merge(temp,bde153.t1,by="subject.id", all.x=TRUE)
pbde.t1 <-temp

#Step 10 already completed for cotinine
```

```{r step 11}
####Step 11: Change Units to make the range of values easier to work with 
metal.t1 <- metal.t1 %>%
mutate(lead.t1.res = lead.t1.res*1000) #change unit from umol/L to nmol/L

#OCPs: change unit from ug/L to ng/L
ocp.t1 <- ocp.t1 %>%
mutate(bbhc.t1.res = bbhc.t1.res*1000)
ocp.t1 <- ocp.t1 %>%
mutate(dde.t1.res = dde.t1.res*1000)
ocp.t1 <- ocp.t1 %>%
mutate(oxychlor.t1.res = oxychlor.t1.res*1000)
ocp.t1 <- ocp.t1 %>%
mutate(transnona.t1.res = transnona.t1.res*1000)

#PCBs: change unit from ug/L to ng/L
pcb.t1 <- pcb.t1 %>%
mutate(aroclor.t1.res = aroclor.t1.res*1000)
pcb.t1 <- pcb.t1 %>%
mutate(pcb118.t1.res = pcb118.t1.res*1000)
pcb.t1 <- pcb.t1 %>%
mutate(pcb138.t1.res = pcb138.t1.res*1000)
pcb.t1 <- pcb.t1 %>%
mutate(pcb153.t1.res = pcb153.t1.res*1000)
pcb.t1 <- pcb.t1 %>%
mutate(pcb170.t1.res = pcb170.t1.res*1000)
pcb.t1 <- pcb.t1 %>%
mutate(pcb180.t1.res = pcb180.t1.res*1000)
pcb.t1 <- pcb.t1 %>%
mutate(pcb187.t1.res = pcb187.t1.res*1000)

#PBDEs: change unit from ug/L to ng/L
pbde.t1 <- pbde.t1 %>%
mutate(bde47.t1.res = bde47.t1.res*1000)
pbde.t1 <- pbde.t1 %>%
mutate(bde99.t1.res = bde99.t1.res*1000)
pbde.t1 <- pbde.t1 %>%
mutate(bde100.t1.res = bde100.t1.res*1000)
pbde.t1 <- pbde.t1 %>%
mutate(bde153.t1.res = bde153.t1.res*1000)

cot.t1 <- cot.t1 %>%
mutate(cot.t1.res = cot.t1.res*1000) #change unit from ug/L to ng/L


#Bonus: for metals only: convert from nmol/L to ug/L
metal.grams.t1 <- metal.t1 #make a copy of metal.t1

#molecular weights (source: https://www.lenntech.com/calculators/molecular/molecular-weight-calculator.htm)
##arsenic: 74.92 g/mol 
##cadmium: 112.41 g/mol
##lead: 207.2 g/mol
##manganese: 54.94 g/mol
##mercury: 200.59 g/mol
as <- 74.92
cd <- 112.41
pb <- 207.2
mn <- 54.94
hg <- 200.59

as.gpernmol <- as/1e9 #divide by 1e9 because chemical concentrations are in nmol/L. Thus we need to find the molarity of these metals in g/nmol, not g/mol, to do the conversions. 
cd.gpernmol <- cd/1e9
pb.gpernmol <- pb/1e9
mn.gpernmol <- mn/1e9
hg.gpernmol <- hg/1e9

g.to.ug <- 1e6 #converts metal concentrations from g/L to ug/L, which is easier to work with

metal.grams.t1 <- metal.grams.t1 %>%
mutate(arsenic.t1.res = arsenic.t1.res*as.gpernmol*g.to.ug)
metal.grams.t1 <- metal.grams.t1 %>%
mutate(cadmium.t1.res = cadmium.t1.res*cd.gpernmol*g.to.ug)
metal.grams.t1 <- metal.grams.t1 %>%
mutate(lead.t1.res = lead.t1.res*pb.gpernmol*g.to.ug)
metal.grams.t1 <- metal.grams.t1 %>%
mutate(manganese.t1.res = manganese.t1.res*mn.gpernmol*g.to.ug)
metal.grams.t1 <- metal.grams.t1 %>%
mutate(mercury.t1.res = mercury.t1.res*hg.gpernmol*g.to.ug)

rm(as, cd, pb, mn, hg, cd.gpernmol, as.gpernmol, pb.gpernmol, mn.gpernmol, hg.gpernmol, g.to.ug) #clean up environment as we go
```

```{r sum pcbs, dehp, OCP, pbdes}
####Bonus step: make "sum.pcb", "sum.dehp" variables
####Extra step specific to the PCBs: Make a new variable for the sum of PCBs weighted by their molecular weight (UNADJUSTED, need to divide by lipid concentration in subsequent step)
pcb.t1$sum.pcb.t1.flag <- rep(0, dim(pcb.t1)[1]) #make an empty 'spacer' column. This will make it much easier to remove the ".lod" columns in a subsequent step
pcb.t1$sum.pcb.t1.flag <- NA 

#the molecular weight of the 5 congeners detectable in at least 50% of the population is as follows:
#source: filesystem:chrome-extension://bomfdkbfpdhijjbeoicnfhjbdhncfhig/persistent/5E0C6E9ED02211E9800EBB9BDE8EC746/pp_attachments/237a6e55-8fe7-07c7-aa63-61e46866c308
##118: 337.5 g/mol
##138: 360.9 g/mol
##153: 360.9 g/mol
##170: 395.3 g/mol
##180: 395.3 g/mol 
###ave molecular weight = 369.98

#we will divide the concentration of each congener by individual MW and multiply by the average MW to weigh the congeners. 

pcb.t1$sum.pcb.t1.res <- rep(0, dim(pcb.t1)[1])
pcb.t1$sum.pcb.t1.res <- (pcb.t1$pcb118.t1.res/337.5*369.98 +pcb.t1$pcb138.t1.res/360.9*369.98 +pcb.t1$pcb153.t1.res/360.9*369.98 +pcb.t1$pcb170.t1.res/395.3*369.98 +pcb.t1$pcb180.t1.res/395.3*369.98)

#old version: if LOD cutoff is 40%, also include PCB187
##187: 395.3 g/mol 
###thus average molecular weight is 374.2 g/mol.
#pcb.t1$sum.pcb.t1.res <- (pcb.t1$pcb118.t1.res/337.5*374.2 +pcb.t1$pcb138.t1.res/360.9*374.2 +pcb.t1$pcb153.t1.res/360.9*374.2 +pcb.t1$pcb170.t1.res/395.3*374.2 +pcb.t1$pcb180.t1.res/395.3*374.2 +pcb.t1$pcb187.t1.res/395.3*374.2)

#check
pcb.t1[1:10,]
#test the "sum.pcb.t1.res" column for the first subject:
22/337.5*369.98+ 47/360.9*369.98+ 110/360.9*369.98 + 29/395.3*369.98 + 100/395.3*369.98 
##sum.pcb.t1 for the first subject is 305.8044: it's working as expected

rm(aroclor.t1, pcb118.t1, pcb138.t1, pcb153.t1, pcb170.t1, pcb180.t1, pcb187.t1) #clean up the environment as we go 

####Extra step specific to the phthalates: Make a new variable for the sum of the DEHP-derrived metabolites
phth.t1$sum.dehp.t1.flag <- rep(0, dim(phth.t1)[1]) #make an empty 'spacer' column. This will make it much easier to remove the ".lod" columns in a subsequent step
phth.t1$sum.dehp.t1.flag <- NA 

#the molecular weight of each DEHP-derrived metabolite is as follows:
##MEHHP: 294.34 g/mol
##MEHP: 278.34 g/mol
##MEOHP: 292.33 g/mol

###thus average molecular weight is 288.34 g/mol.

#we will divide the concentration of each metabolite by individual MW and multiply by the average MW to weigh the metabolites. 

phth.t1$sum.dehp.t1.res <- rep(0, dim(phth.t1)[1])
phth.t1$sum.dehp.t1.res <- (phth.t1$mehhp.t1.res/294.34*288.34 +phth.t1$mehp.t1.res/278.34*288.34 +phth.t1$meohp.t1.res/292.33*288.34)

#check
phth.t1[1:10,]
#test the "sum.dehp.t1.res" column for the first subject:
2.1/294.34*288.34 +1.3/278.34*288.34 +1.7/292.33*288.34
##sum.dehp.t1.res for the first subject is 5.080695: it's working as expected

rm(mbp.t1, mbzp.t1, mcpp.t1, mehhp.t1, mehp.t1, meohp.t1, mep.t1) #clean up the environment as we go

####Extra step specific to the OCPs: Make a new variable for the sum of oxychlordane, PCBs
ocp.t1$sum.ocp.t1.flag <- rep(0, dim(ocp.t1)[1]) #make an empty 'spacer' column. This will make it much easier to remove the ".lod" columns in a subsequent step
ocp.t1$sum.ocp.t1.flag <- NA 

#the molecular weight of the 2 highly correlated OCPs:
##trans nonachlor: 444.2 g/mol (from https://pubchem.ncbi.nlm.nih.gov/compound/trans-nonachlor)
##oxychlordane: 423.7 g/mol (from https://pubchem.ncbi.nlm.nih.gov/compound/Oxychlordane#section=GC-MS)
###thus average molecular weight is 433.95 g/mol.

#we will divide the concentration of each metabolite by individual MW and multiply by the average MW to weigh the metabolites. 

ocp.t1$sum.oxyc_tnona.t1.res <- rep(0, dim(ocp.t1)[1])
ocp.t1$sum.oxyc_tnona.t1.res <- (ocp.t1$transnona.t1.res/444.2*433.95 +ocp.t1$oxychlor.t1.res/423.7*433.95 )

rm(oxychlor.t1, transnona.t1, dde.t1, bbhc.t1) #clean up the environment as we go


####Extra step specific to the PBDEs: Make a new variable for the sum BDE47, BDE99, BDE100, and BDE153 (added -AY)
pbde.t1$sum.pbde.t1.flag <- rep(0, dim(pbde.t1)[1]) #make an empty 'spacer' column. This will make it much easier to remove the ".lod" columns in a subsequent step

pbde.t1$sum.pbde.t1.flag <- NA 

#the molecular weight of the 4 pbdes (found on pubchem):
##BDE47: 485.8 g/mol (from https://pubchem.ncbi.nlm.nih.gov/compound/2_2_4_4_-Tetrabromodiphenyl-ether)
##BDE99: 564.7 g/mol (from https://pubchem.ncbi.nlm.nih.gov/compound/1_2_4-tribromo-5-_2_4-dibromophenoxy_benzene)
##BDE100: 564.7 g/mol (from https://pubchem.ncbi.nlm.nih.gov/compound/1_3_5-Tribromo-2-_2_4-dibromophenoxy_benzene)
##BDE153: 643.6 g/mol (from https://pubchem.ncbi.nlm.nih.gov/compound/155166)
##Average: 564.7 g/mol

#we will divide the concentration of each metabolite by individual MW and multiply by the average MW to weigh the metabolites. 

pbde.t1$sum.pbde.t1.res <- rep(0, dim(pbde.t1)[1])
pbde.t1$sum.pbde.t1.res <- (pbde.t1$bde47.t1.res/485.8*564.7 + pbde.t1$bde99.t1.res/564.7*564.7 +pbde.t1$bde100.t1.res/564.7*564.7 + pbde.t1$bde153.t1.res/643.6*564.7)

```

```{r step 11}
####Step 11: Make lipid/ creatinine/ SG adjustments

####OCPs

#unadjusted
ocp.unadj.t1 <-ocp.t1

#lipid adjusting
ocp.lipid.adj.t1 <-ocp.t1 #make copy of df
ocp.lipid.adj.t1 <- merge(ocp.lipid.adj.t1, lipid.t1,by="subject.id", all.x=TRUE)
##divide [chemical name].t1.res by lipid concentrations 
for (a in (0:4)) {
ocp.lipid.adj.t1[,3+2*a] <- ocp.lipid.adj.t1[,3+2*a] / ocp.lipid.adj.t1$lipid.t1.res
}
##Remove unnecessary rows
ocp.lipid.adj.t1 <- select(ocp.lipid.adj.t1, -c("lipid.t1.flag", "lipid.t1.res")) #drops the lipid columns


####OPPs

#unadjusted
opp.unadj.t1 <-opp.t1

#cre adjusting
opp.cre.adj.t1 <-opp.t1 #make copy of df
opp.cre.adj.t1 <- merge(opp.cre.adj.t1, cre.t1,by="subject.id", all.x=TRUE)
##divide [chemical name].t1.res by creatine concentrations 
for (a in (0:3)) {
opp.cre.adj.t1[,3+2*a] <- opp.cre.adj.t1[,3+2*a] / opp.cre.adj.t1$cre.t1.res
}
##Remove unnecessary rows
opp.cre.adj.t1 <- select(opp.cre.adj.t1, -c("cre.t1.flag", "cre.t1.res")) #drops the cre concentration, sg columns

#sg standardizing
opp.sg.adj.t1 <-opp.t1 #make copy of df
opp.sg.adj.t1 <- merge(opp.sg.adj.t1, sg.t1,by="subject.id", all.x=TRUE)
##standardize each chemical concentration by sg
sg.median <- median(sg.t1$sg.t1.res) #calculate median
for (a in (0:4)) {
opp.sg.adj.t1[,3+2*a] <- opp.sg.adj.t1[,3+2*a]*((sg.median-1)/(opp.sg.adj.t1$sg.t1.res-1))
}
##Remove unnecessary rows
opp.sg.adj.t1 <- select(opp.sg.adj.t1, -c("sg.t1.flag", "sg.t1.res")) 


####pcbs

#unadjusted
pcb.unadj.t1 <-pcb.t1

#lipid adjusting
pcb.lipid.adj.t1 <-pcb.t1 #make copy of df
pcb.lipid.adj.t1 <- merge(pcb.lipid.adj.t1, lipid.t1,by="subject.id", all.x=TRUE)
##divide [chemical name].t1.res by lipid concentrations 
for (a in (0:7)) {
pcb.lipid.adj.t1[,3+2*a] <- pcb.lipid.adj.t1[,3+2*a] / pcb.lipid.adj.t1$lipid.t1.res
}
##Remove unnecessary rows
pcb.lipid.adj.t1 <- select(pcb.lipid.adj.t1, -c("lipid.t1.flag", "lipid.t1.res")) #drops the lipid columns


####pbdes

#unadjusted
pbde.unadj.t1 <-pbde.t1

#lipid adjusting
pbde.lipid.adj.t1 <-pbde.t1 #make copy of df
pbde.lipid.adj.t1 <- merge(pbde.lipid.adj.t1, lipid.t1,by="subject.id", all.x=TRUE)
##divide [chemical name].t1.res by lipid concentrations 
for (a in (0:4)) {
pbde.lipid.adj.t1[,3+2*a] <- pbde.lipid.adj.t1[,3+2*a] / pbde.lipid.adj.t1$lipid.t1.res
}
##Remove unnecessary rows
pbde.lipid.adj.t1 <- select(pbde.lipid.adj.t1, -c("lipid.t1.flag", "lipid.t1.res")) #drops the lipid columns


#####phthalates

#unadjusted
phth.unadj.t1 <-phth.t1

#cre adjusting
phth.cre.adj.t1 <-phth.t1 #make copy of df
phth.cre.adj.t1 <- merge(phth.cre.adj.t1, cre.t1,by="subject.id", all.x=TRUE)
##divide [chemical name].t1.res by creatine concentrations 
for (a in (0:7)) {
phth.cre.adj.t1[,3+2*a] <- phth.cre.adj.t1[,3+2*a] / phth.cre.adj.t1$cre.t1.res
}
##Remove unnecessary rows
phth.cre.adj.t1 <- select(phth.cre.adj.t1, -c("cre.t1.flag", "cre.t1.res")) #drops the cre concentration, sg columns

#sg standardizing
phth.sg.adj.t1 <-phth.t1 #make copy of df
phth.sg.adj.t1 <- merge(phth.sg.adj.t1, sg.t1,by="subject.id", all.x=TRUE)
##standardize each chemical concentration by sg
for (a in (0:7)) {
phth.sg.adj.t1[,3+2*a] <- phth.sg.adj.t1[,3+2*a]*((sg.median-1)/(phth.sg.adj.t1$sg.t1.res-1))
}
##Remove unnecessary rows
phth.sg.adj.t1 <- select(phth.sg.adj.t1, -c("sg.t1.flag", "sg.t1.res")) 

```

```{r step 12}
####Step 12: Make the datasets
#make a single dataframe with all the chemicals 
## Metal concentrations are measured in ng/L
## OCPs and PCBs and PBDEs are lipid adjusted. Metals, cotinine are not
## OPPs and phthalates are standardized by specific gravity. 

temp <- merge(metal.grams.t1, ocp.lipid.adj.t1,by="subject.id", all.x=TRUE) 
temp <- merge(temp, opp.sg.adj.t1,by="subject.id", all=TRUE) 
temp <- merge(temp, phth.sg.adj.t1,by="subject.id", all=TRUE)
temp <- merge(temp, pcb.lipid.adj.t1,by="subject.id", all=TRUE)
temp <- merge(temp, cot.t1,by="subject.id", all=TRUE)
temp <- merge(temp, pbde.lipid.adj.t1,by="subject.id", all=TRUE)
chem.descriptive <- temp #chem dataframe includes the ".lod" column, useful when determining the % of participants below the limit of detection, descriptive

chem.analysis <- chem.descriptive #make a copy of chem.descriptive

n <- dim(chem.analysis)[2]
chem.analysis <- chem.analysis %>%
select(-c(seq(2,n,2))) #deletes the even numbered columns 
#check
chem.analysis[1:10,] #confirms that the even numbered columns (the '.lod' columns) are all deleted, but nothing else is. 

#log2 transform all chemical concentrations in chem.analysis
n <- dim(chem.analysis)[2] #reset n for subsequent step

##metals
chem.analysis <- mutate(chem.analysis, log2.arsenic.t1 = log2(arsenic.t1.res))
chem.analysis <- mutate(chem.analysis, log2.cadmium.t1 = log2(cadmium.t1.res))
chem.analysis <- mutate(chem.analysis, log2.lead.t1 = log2(lead.t1.res))
chem.analysis <- mutate(chem.analysis, log2.manganese.t1 = log2(manganese.t1.res))
chem.analysis <- mutate(chem.analysis, log2.mercury.t1 = log2(mercury.t1.res))

##OCPs
chem.analysis <- mutate(chem.analysis, log2.bbhc.t1 = log2(bbhc.t1.res)) 
chem.analysis <- mutate(chem.analysis, log2.dde.t1 = log2(dde.t1.res))
chem.analysis <- mutate(chem.analysis, log2.oxychlor.t1 = log2(oxychlor.t1.res))
chem.analysis <- mutate(chem.analysis, log2.transnona.t1 = log2(transnona.t1.res))
chem.analysis <- mutate(chem.analysis, log2.sum.oxyc_tnona.t1 = log2(sum.oxyc_tnona.t1.res))

##OPPs
chem.analysis <- mutate(chem.analysis, log2.dep.t1 = log2(dep.t1.res))
chem.analysis <- mutate(chem.analysis, log2.detp.t1 = log2(detp.t1.res))
chem.analysis <- mutate(chem.analysis, log2.dmdtp.t1 = log2(dmdtp.t1.res))
chem.analysis <- mutate(chem.analysis, log2.dmp.t1 = log2(dmp.t1.res))
chem.analysis <- mutate(chem.analysis, log2.dmtp.t1 = log2(dmtp.t1.res))

##phthalates
chem.analysis <- mutate(chem.analysis, log2.mbp.t1 = log2(mbp.t1.res))
chem.analysis <- mutate(chem.analysis, log2.mbzp.t1 = log2(mbzp.t1.res))
chem.analysis <- mutate(chem.analysis, log2.mcpp.t1 = log2(mcpp.t1.res))
chem.analysis <- mutate(chem.analysis, log2.mehhp.t1 = log2(mehhp.t1.res))
chem.analysis <- mutate(chem.analysis, log2.mehp.t1 = log2(mehp.t1.res))
chem.analysis <- mutate(chem.analysis, log2.meohp.t1 = log2(meohp.t1.res))
chem.analysis <- mutate(chem.analysis, log2.mep.t1 = log2(mep.t1.res))
chem.analysis <- mutate(chem.analysis, log2.sum.dehp.t1 = log2(sum.dehp.t1.res))

##Polychlorinated biphenyls
chem.analysis <- mutate(chem.analysis, log2.aroclor.t1 = log2(aroclor.t1.res))
chem.analysis <- mutate(chem.analysis, log2.pcb118.t1 = log2(pcb118.t1.res))
chem.analysis <- mutate(chem.analysis, log2.pcb138.t1 = log2(pcb138.t1.res))
chem.analysis <- mutate(chem.analysis, log2.pcb153.t1 = log2(pcb153.t1.res))
chem.analysis <- mutate(chem.analysis, log2.pcb170.t1 = log2(pcb170.t1.res))
chem.analysis <- mutate(chem.analysis, log2.pcb180.t1 = log2(pcb180.t1.res))
chem.analysis <- mutate(chem.analysis, log2.pcb187.t1 = log2(pcb187.t1.res))
chem.analysis <- mutate(chem.analysis, log2.sum.pcb.t1 = log2(sum.pcb.t1.res))

##Polybrominated diphenyl ethers
chem.analysis <- mutate(chem.analysis, log2.bde47.t1 = log2(bde47.t1.res))
chem.analysis <- mutate(chem.analysis, log2.bde99.t1 = log2(bde99.t1.res))
chem.analysis <- mutate(chem.analysis, log2.bde100.t1 = log2(bde100.t1.res))
chem.analysis <- mutate(chem.analysis, log2.bde153.t1 = log2(bde153.t1.res))
chem.analysis <- mutate(chem.analysis, log2.sum.pbde.t1 = log2(sum.pbde.t1.res))

#tobacco metabolites
chem.analysis <- mutate(chem.analysis, log2.cot.t1 = log2(cot.t1.res))

#remove the unnecessary non-transformed columns from 
chem.analysis <- chem.analysis %>%
select(-c(2:n)) #deletes the untransformed .res columns

```

#################################################
#####Part 3
#################################################
#Make the final datasets. Save all data to your computer's hard drive. 

```{r save data}
setwd("/home/ayonkman/Desktop/Cleaned Data") 
#Make final datasets with chemical, demographic information
mirec.descriptive <- merge(chem.descriptive, demog,by="subject.id", all=TRUE)
mirec.analysis <- merge(chem.analysis, demog,by="subject.id", all=TRUE)

#taking out NA's to see what I'm working with -AY
attach(mirec.analysis)
ay.analysis <- mirec.analysis[!is.na(log2.arsenic.t1&log2.cadmium.t1&log2.lead.t1&log2.manganese.t1&log2.mercury.t1&log2.bbhc.t1&log2.dde.t1&log2.oxychlor.t1&log2.transnona.t1&log2.sum.oxyc_tnona.t1&log2.mbp.t1&log2.mbzp.t1&log2.mcpp.t1&log2.mehhp.t1&log2.mehp.t1&log2.meohp.t1&log2.mep.t1&log2.sum.dehp.t1&log2.dep.t1&log2.detp.t1&log2.dmdtp.t1&log2.dmp.t1&log2.dmtp.t1&log2.aroclor.t1&log2.pcb118.t1&log2.pcb138.t1&log2.pcb153.t1&log2.pcb170.t1&log2.pcb180.t1&log2.pcb187.t1&log2.sum.pcb.t1&log2.bde47.t1&log2.bde99.t1&log2.bde100.t1&log2.bde153.t1&log2.sum.pcb.t1&log2.cot.t1&viq&piq&fsiq),]
detach(mirec.analysis)

# to find the % <LOD of my data -AY
attach(mirec.descriptive)
ay.descriptive <- mirec.descriptive[!is.na(arsenic.t1.res&cadmium.t1.res&lead.t1.res&manganese.t1.res&mercury.t1.res&bbhc.t1.res&dde.t1.res&oxychlor.t1.res&transnona.t1.res&mbp.t1.res&mbzp.t1.res&mcpp.t1.res&mehhp.t1.res&mehp.t1.res&meohp.t1.res&mep.t1.res&sum.dehp.t1.res&dep.t1.res&detp.t1.res&dmdtp.t1.res&dmp.t1.res&dmtp.t1.res&aroclor.t1.res&pcb118.t1.res&pcb138.t1.res&pcb153.t1.res&pcb170.t1.res&pcb180.t1.res&pcb187.t1.res&sum.pcb.t1.res&bde47.t1.res&bde99.t1.res&bde100.t1.res&bde153.t1.res&sum.pcb.t1.res&cot.t1.res&viq&piq&fsiq),]
detach(mirec.descriptive)
```

```{r}

# Finding % >LOD for each chemical-AY

100-((sum(ay.descriptive$arsenic.t1.flag)/521)*100)
100-((sum(ay.descriptive$cadmium.t1.flag)/521)*100)
100-((sum(ay.descriptive$lead.t1.flag)/521)*100)
100-((sum(ay.descriptive$manganese.t1.flag)/521)*100)
100-((sum(ay.descriptive$mercury.t1.flag)/521)*100)
100-((sum(ay.descriptive$bbhc.t1.flag)/521)*100)
100-((sum(ay.descriptive$dde.t1.flag)/521)*100)
100-((sum(ay.descriptive$oxychlor.t1.flag)/521)*100)
100-((sum(ay.descriptive$transnona.t1.flag)/521)*100)
100-((sum(ay.descriptive$dep.t1.flag)/521)*100)
100-((sum(ay.descriptive$detp.t1.flag)/521)*100)
100-((sum(ay.descriptive$dmdtp.t1.flag)/521)*100)
100-((sum(ay.descriptive$dmp.t1.flag)/521)*100)
100-((sum(ay.descriptive$dmtp.t1.flag)/521)*100)
100-((sum(ay.descriptive$mbp.t1.flag)/521)*100)
100-((sum(ay.descriptive$mbzp.t1.flag)/521)*100)
100-((sum(ay.descriptive$mcpp.t1.flag)/521)*100)
100-((sum(ay.descriptive$mehhp.t1.flag)/521)*100)
100-((sum(ay.descriptive$mehp.t1.flag)/521)*100)
100-((sum(ay.descriptive$meohp.t1.flag)/521)*100)
100-((sum(ay.descriptive$mep.t1.flag)/521)*100)
100-((sum(ay.descriptive$aroclor.t1.flag)/521)*100)
100-((sum(ay.descriptive$pcb118.t1.flag)/521)*100)
100-((sum(ay.descriptive$pcb138.t1.flag)/521)*100)
100-((sum(ay.descriptive$pcb153.t1.flag)/521)*100)
100-((sum(ay.descriptive$pcb170.t1.flag)/521)*100)
100-((sum(ay.descriptive$pcb180.t1.flag)/521)*100)
100-((sum(ay.descriptive$pcb187.t1.flag)/521)*100)
100-((sum(ay.descriptive$bde47.t1.flag)/521)*100)
100-((sum(ay.descriptive$bde99.t1.flag)/521)*100)
100-((sum(ay.descriptive$bde100.t1.flag)/521)*100)
100-((sum(ay.descriptive$bde153.t1.flag)/521)*100)
100-((sum(ay.descriptive$cot.t1.flag)/521)*100)

```

```{r save data}
  setwd("/home/ayonkman/Desktop/Cleaned Data") 

#saving analysis with no NA's
write.table(ay.analysis, file="MIREC Loader Results/AY_MIREC_Analysis_July22_2020.csv", sep=',', row.names=FALSE) 

#saving descriptive dataset with no NA's
write.table(ay.descriptive, file="MIREC Loader Results/AY_MIREC_Descriptive_July22_2020.csv", sep=',', row.names=FALSE)

#save the descriptive dataset
write.table(mirec.descriptive, file="MIREC Loader Results/MIREC_descriptive_Feb20_2020.csv", sep=',', row.names=FALSE) 

#save the analysis dataset
write.table(mirec.analysis, file="MIREC Loader Results/MIREC_analysis_Feb20_2020.csv", sep=',', row.names=FALSE) 

#optional:
#save cleaned demographics data, no chemical data 

write.table(demog, file="MIREC Loader Results/MIREC_demographics.csv", sep=',', row.names=FALSE) 

#save the chemical data, no demographics data 
write.table(chem.descriptive, file="MIREC Loader Results/MIREC_chemicals_descriptive.csv", sep=',', row.names=FALSE) 
write.table(chem.analysis, file="MIREC Loader Results/MIREC_chemicals_analysis.csv", sep=',', row.names=FALSE) 

#save data on groups of chemicals. Allows you to pick and choose what chemicals, adjustments you want. 
write.table(metal.t1, file="MIREC Loader Results/metal.unadj.csv", sep=',', row.names=FALSE)

write.table(metal.grams.t1, file="MIREC Loader Results/metal.grams.unadj.csv", sep=',', row.names=FALSE) 

write.table(ocp.unadj.t1, file="MIREC Loader Results/ocp.unadj.csv", sep=',', row.names=FALSE) 
write.table(ocp.lipid.adj.t1, file="MIREC Loader Results/ocp.lipid.adj.csv", sep=',', row.names=FALSE) 

write.table(pcb.unadj.t1, file="MIREC Loader Results/pcb.unadj.csv", sep=',', row.names=FALSE) 
write.table(pcb.lipid.adj.t1, file="MIREC Loader Results/pcb.lipid.adj.csv", sep=',', row.names=FALSE) 

write.table(pcb.unadj.t1, file="MIREC Loader Results/pbde.unadj.csv", sep=',', row.names=FALSE) 
write.table(pcb.lipid.adj.t1, file="MIREC Loader Results/pbde.lipid.adj.csv", sep=',', row.names=FALSE) 

write.table(phth.unadj.t1, file="MIREC Loader Results/phth.unadj.csv", sep=',', row.names=FALSE) 
write.table(phth.cre.adj.t1, file="MIREC Loader Results/phth.cre.adj.csv", sep=',', row.names=FALSE) 
write.table(phth.sg.adj.t1, file="MIREC Loader Results/phth.sg.adj.csv", sep=',', row.names=FALSE) 

write.table(cot.t1, file="MIREC Loader Results/cot.unadj.csv", sep=',', row.names=FALSE) 

#save the adjustors, if you want to use them as variables in models. 
write.table(lipid.t1, file="MIREC Loader Results/lipid.csv", sep=',', row.names=FALSE) 
write.table(cre.t1, file="MIREC Loader Results/cre.csv", sep=',', row.names=FALSE) 
write.table(sg.t1, file="MIREC Loader Results/sg.csv", sep=',', row.names=FALSE) 
```
